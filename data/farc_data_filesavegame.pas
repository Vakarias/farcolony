{======(C) Copyright Aug.2009-2012 Jean-Francois Baconnet All rights reserved==============

        Title:  FAR Colony
        Author: Jean-Francois Baconnet
        Project Started: August 16 2009
        Platform: Delphi
        License: GPLv3
        Website: http://farcolony.sourceforge.net/

        Unit: savegame file management

============================================================================================
********************************************************************************************
Copyright (c) 2009-2012, Jean-Francois Baconnet

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*******************************************************************************************}
unit farc_data_filesavegame;

interface

uses
   SysUtils
   ,TypInfo
   ,Windows
   ,XMLIntf;

///<summary>
///   load the current game
///</summary>
procedure FCMdFSG_Game_Load;

///<summary>
///   save the current game
///</summary>
procedure FCMdFSG_Game_Save;

///<summary>
///   save the current game and flush all other save game files than the current one
///</summary>
procedure FCMdFSG_Game_SaveAndFlushOther;

//===========================END FUNCTIONS SECTION==========================================

implementation

uses
   farc_common_func
   ,farc_data_files
   ,farc_data_game
   ,farc_data_infrprod
   ,farc_data_init
   ,farc_data_messages
   ,farc_data_missionstasks
   ,farc_data_univ
   ,farc_game_cps
   ,farc_game_cpsobjectives
   ,farc_game_gameflow
   ,farc_univ_func
   ,farc_main;

//===================================================END OF INIT============================
//===========================END FUNCTIONS SECTION==========================================

procedure FCMdFSG_Game_Load;
{:Purpose: load the current game.
   Additions:
      -2012May24- *add: CPS - Viability thresholds.
      -2012May13- *add: CSM event: etRveFoodShortage, addition of the direct death period + death fractional value.
      -2012May12- *add: CSM event: etRveOxygenShortage, etRveWaterOverload, etRveWaterShortage, etRveFoodOverload and etRveFoodShortage.
      -2012May06- *add: CSM event: etRveOxygenOverload.
      -2012Apr29- *mod: CSM event token are loaded by their full names now.
                  *mod: CSM event modifiers and data are loaded according to the new changes in the data structure.
      -2012Apr15- *add: completion of colony's reserves.
                  *fix: correctly load the colony level.
      -2012Mar14- *fix: colony's production matrix - correct a data mismatch error in the production matrix item loading.
                  *fix: owned infrastructures - forgot to include MISC and INTELLIGENCE function for saving them and their possible specific data.
      -2012Mar13- *add: selective loading for otEcoIndustrialForce data.
      -2012Mar11- *add: viability objective: otEcoIndustrialForce.
      -2012Feb09- *add: load directly the CPS objective type.
      -2012Jan11- *add: production matrix / CPMI_storageType.
      -2012Jan04- *add: owned infrastructures / power generated by custom effect.
      -2011Dec11- *mod: transfert the disable state for production mode of the production matrix into the owned infrastructure data structure.
      -2011Dec08- *add: owned infrastructures / production function / PM_matrixItemMax.
      -2011Nov30- *add: complete surveyed resource spot data for infrastructures.
      -2011Nov22- *fix: initialize correctly the CAB queue of all loaded settlement (even before the CAB queue itself is loaded.
                        prevent: crash during the commit of the setup of an assembling/building + crash during the loading of the CAB queue.
      -2011Nov18- *add: update hardcoded resource data w/ updated data structure.
      -2011Nov07- *add: complete production mode data for owned infrastructures.
                  *add: put full function name for owned infrastuctures.
                  *code: optimize owned infrastructure status and funtion loading.
      -2011Nov01- *add: complete the production matrix.
      -2011Oct19- *add: add, in list of surveyed resources, the specificity concerning the Ore field type.
      -2011Oct17- *add: complete the production matrix loading.
      -2011Oct11- *fix: forgot to set the size of the region dynamic array.
                  *fix: correction on spotSizCurr attribute loading.
      -2011Oct10- *add: list for surveyed resources.
      -2011Jul31- *add: infrastructure status istDisabledByEE.
      -2011Jul19- *add: CSM Energy module - storage data.
      -2011Jul13- *add: infrastructure consumed power.
      -2011Jul12- *add: CSM - Energy data.
      -2011Jul07- *add: colonies' production matrix.
      -2011May25- *rem: infrastructure - converted housing, useless state.
      -2011May15- *add: colony's infrastructure - CAB worked hours.
      -2011May05- *mod: complete change of colony's storage loading.
      -2011Apr26- *add: colonies' assigned population data.
                  *add: colonies' construction workforce.
      -2011Apr24- *add: energy output for Energy class infrastructures.
      -2011Apr20- *add: CPS - isEnabled.
      -2011Mar16-	*add: colonies' storages + reserves.
      -2011Mar09- *add: infrastructure's CAB duration.
                  *add: colonies' CAB queue.
      -2011Mar07- *add: converted housing infrastructures.
      -2011Feb14- *add: initialize region's settlement data.
      -2011Feb12- *add: extra task's data.
                  *add: settlements.
      -2011Feb08- *add: full status token loading, independent of the index.
      -2011Feb01- *add: economic & industrial output.
      -2010Dec29- *add: SPM cost storage data.
      -2010Dec19- *add: entities higher hq level present in the faction.
      -2010Nov08- *add: entities UC reserve.
      -2010Nov03- *add: SPMi duration.
      -2010Oct24- *add: HQ presence data for each colony.
      -2010Oct11- *add: player's faction status of the 3 categories.
      -2010Oct07- *add: memes values + policy status.
      -2010Sep29- *add: entity's bureaucracy and corruption modifiers.
      -2010Sep23- *fix: entity's bureaucracy and corruption load.
      -2010Sep22- *add: bureaucracy and corruption entities data.
                  *add: SPMi isSet data.
      -2010Sep21- *add: spm settings for entities.
      -2010Sep16- *add: entities code.
      -2010Sep07- *add: loading in specific file now, including date/time: name-yr-mth-day-h-mn.
      -2010Aug30- *add: CSM Phase list.
      -2010Aug19- *add: population type: militia.
      -2010Aug16- *add: population type: rebels.
      -2010Aug09- *add: CSM event duration.
      -2010Aug02- *add: CSM event health modifier.
      -2010Jul27- *add: CSM event level + economic & industrial output modifier.
      -2010Jul21- *add: csmTime data.
      -2010Jul02- *add: tasklisk string data.
      -2010Jun08- *add: space unit: include the docked sub data structure.
                  *fix: for each existing colony, the related orbital object data structure is updated.
      -2010Jun07- *add: display cps panel if cps is used and there's one colony.
      -2010May30- *add: colony's population sub-datastructure.
      -2010May27- *add: csm data pcap, spl, qol and heal.
      -2010May19- *add: colony infrastructures: status.
      -2010May18- *add: colony infrastructures.
      -2010May12- *add: in process task data phase.
      -2010May10- *add: the two time2xfert data.
      -2010May05- *add: TITP_regIdx.
      -2010May04- *add: TITP_timeOrg, TITP_orgType, TITP_timeDecel, TITP_accelbyTick.
                  *mod: threads loading is disabled.
      -2010Mar31- *add: colony level.
      -2010Mar27- *add space unit docked data.
      -2010Mar22- *add: cps time left.
      -2010Mar13- *add: cps data.
      -2010Mar03- *add: owned colonies.
      -2009Dec19- *add: player's sat location.
      -2009Dec18- *add: sat location for owned space unit.
      -2009Nov28- *add messages queue.
      -2009Nov27- *add TITP_usedRMassV.
      -2009Nov12- *add threads.
      -2009Nov10- *add tasklist in process.
      -2009Nov08- *add owned space units.
}
var
   GLxmlCAB
   ,GLxmlCol
   ,GLxmlColsub
   ,GLxmlColsub1
   ,GLxmlDock
   ,GLxmlEntRoot
   ,GLxmlEntSubRoot
   ,GLxmlEnt
   ,GLxmlInfra
   ,GLxmlItm
   ,GLxmlMsg
   ,GLxmlCSMpL
   ,GLxmlCSMpLsub
   ,GLxmlProdMode
   ,GLxmlMatrixItem
   ,GLxmlProdMatrix
   ,GLxmlProdMatrixSource
   ,GLxmlSPMset
   ,GLxmlSpOwn
   ,GLxmlTskInPr
   ,GLxmlViaObj
   ,GLxmlSurveyRsrc
   ,GLxmlSurveyRegion
   ,GLxmlSurveyRSpot: IXMLNode;

   GLcabCnt
   ,GLcabValue
   ,GLcolMax
   ,GLentCnt
   ,GLspuMax
   ,GLspuCnt
   ,GLcount
   ,GLcrLineM
   ,GLcvs
   ,GLdock
   ,GLevCnt
   ,GLinfCnt
   ,GLphItm
   ,GLphFac
   ,GLphFacOld
   ,GLprodMatrixCnt
   ,GLregionIdx
   ,GLsettleCnt
   ,GLsettleMax
   ,GLstorageCnt
   ,GLsubCnt
   ,GLsubCnt1
   ,GLtLft
   ,GLenumIndex
   ,GLregionTtl: integer;

   GLcrInt
   ,GLcrLineU: extended;

   GLisCPSenabled: boolean;

   GLcurrDir
   ,GLcurrG
   ,GLsettleType: string;

   GLvObjList: array of TFCRcpsObj;

   GLoobjRow: TFCRufStelObj;
begin
   FCMdF_ConfigurationFile_Load(true);
   GLcurrDir:=FCVdiPathConfigDir+'SavedGames\'+FCRplayer.P_gameName;
   GLcurrG:=IntToStr(FCRplayer.P_currentTimeYear)
      +'-'+IntToStr(FCRplayer.P_currentTimeMonth)
      +'-'+IntToStr(FCRplayer.P_currentTimeDay)
      +'-'+IntToStr(FCRplayer.P_currentTimeHour)
      +'-'+IntToStr(FCRplayer.P_currentTimeMinut)
      +'.xml';
   if (DirectoryExists(GLcurrDir))
      and (FileExists(GLcurrDir+'\'+GLcurrG))
   then
   begin
      {.read the document}
      FCWinMain.FCXMLsave.FileName:=GLcurrDir+'\'+GLcurrG;
      FCWinMain.FCXMLsave.Active:=true;
      {.read the main section}
      GLxmlItm:=FCWinMain.FCXMLsave.DocumentElement.ChildNodes.FindNode('gfMain');
      if GLxmlItm<>nil
      then
      begin
         FCRplayer.P_allegianceFaction:=GLxmlItm.Attributes['facAlleg'];
         FCRplayer.P_viewStarSystem:=GLxmlItm.Attributes['plyrsSSLoc'];
         FCRplayer.P_viewStar:=GLxmlItm.Attributes['plyrsStLoc'];
         FCRplayer.P_viewOrbitalObject:=GLxmlItm.Attributes['plyrsOObjLoc'];
         FCRplayer.P_viewSatellite:=GLxmlItm.Attributes['plyrsatLoc'];
         FCMdF_DBStarOrbitalObjects_Load( FCRplayer.P_viewStarSystem, FCRplayer.P_viewStar );
      end;
      {.read the "timeframe" section}
      GLxmlItm:=FCWinMain.FCXMLsave.DocumentElement.ChildNodes.FindNode('gfTimeFr');
      if GLxmlItm<>nil
      then
      begin
         FCRplayer.P_currentTimeTick:=GLxmlItm.Attributes['tfTick'];
         FCRplayer.P_currentTimeMinut:=GLxmlItm.Attributes['tfMin'];
         FCRplayer.P_currentTimeHour:=GLxmlItm.Attributes['tfHr'];
         FCRplayer.P_currentTimeDay:=GLxmlItm.Attributes['tfDay'];
         FCRplayer.P_currentTimeMonth:=GLxmlItm.Attributes['tfMth'];
         FCRplayer.P_currentTimeYear:=GLxmlItm.Attributes['tfYr'];
      end;
      {.read the "status" section}
      GLxmlItm:=FCWinMain.FCXMLsave.DocumentElement.ChildNodes.FindNode('gfStatus');
      if GLxmlItm<>nil
      then
      begin
         FCRplayer.P_economicStatus:=GLxmlItm.Attributes['statEco'];
         FCRplayer.P_economicViabilityThreshold:=GLxmlItm.Attributes['statEcoThr'];
         FCRplayer.P_socialStatus:=GLxmlItm.Attributes['statSoc'];
         FCRplayer.P_socialViabilityThreshold:=GLxmlItm.Attributes['statSocThr'];
         FCRplayer.P_militaryStatus:=GLxmlItm.Attributes['statSpMil'];
         FCRplayer.P_militaryViabilityThreshold:=GLxmlItm.Attributes['statSpMilThr'];
      end;
      {.read "cps" section}
      GLxmlItm:=FCWinMain.FCXMLsave.DocumentElement.ChildNodes.FindNode('gfCPS');
      if GLxmlItm<>nil
      then
      begin
         GLisCPSenabled:=GLxmlItm.Attributes['cpsEnabled'];
         GLcvs:=GLxmlItm.Attributes['cpsCVS'];
         GLtLft:=GLxmlItm.Attributes['cpsTlft'];
         GLcrInt:=GLxmlItm.Attributes['cpsInt'];
         GLcrLineU:=GLxmlItm.Attributes['cpsCredU'];
         GLcrLineM:=GLxmlItm.Attributes['cpsCredM'];
         GLcount:=0;
         GLxmlViaObj:=GLxmlItm.ChildNodes.First;
         SetLength(GLvObjList, 1);
         while GLxmlViaObj<>nil do
         begin
            SetLength(GLvObjList, length(GLvObjList)+1);
            inc(GLcount);
            GLenumIndex:=GetEnumValue(TypeInfo(TFCEcpsoObjectiveTypes), GLxmlViaObj.Attributes['objTp'] );
            GLvObjList[GLcount].CPSO_type:=TFCEcpsoObjectiveTypes(GLenumIndex);
            if GLenumIndex=-1
            then raise Exception.Create('bad gamesave loading w/CPS objective: '+GLxmlViaObj.Attributes['objTp']);
            GLvObjList[GLcount].CPSO_score:=GLxmlViaObj.Attributes['score'];
            if GLvObjList[GLcount].CPSO_type=otEcoIndustrialForce then
            begin
               GLvObjList[GLcount].CPSO_ifProduct:=GLxmlViaObj.Attributes['product'];
               GLvObjList[GLcount].CPSO_ifThreshold:=GLxmlViaObj.Attributes['threshold'];
            end;
            GLxmlViaObj:=GLxmlViaObj.NextSibling;
         end; //==END== GLxmlViaObj<>nil ==//
         FCcps:=TFCcps.Create(
            GLcvs
            ,GLtLft
            ,GLcrLineM
            ,GLcrInt
            ,GLcrLineU
            ,GLvObjList
            ,GLisCPSenabled
            );
      end; //==END== if GLxmlItm<>nil for CPS ==//
      {.read "taskinprocess" saved game item}
      SetLength(FCGtskListInProc, 1);
      GLxmlItm:=FCWinMain.FCXMLsave.DocumentElement.ChildNodes.FindNode('gfTskLstinProc');
      if GLxmlItm<>nil
      then
      begin
         GLcount:=0;
         GLxmlTskInPr:=GLxmlItm.ChildNodes.First;
         while GLxmlTskInPr<>nil do
         begin
            SetLength(FCGtskListInProc, length(FCGtskListInProc)+1);
            inc(GLcount);
            FCGtskListInProc[GLCount].TITP_enabled:=GLxmlTskInPr.Attributes['tipEna'];
            FCGtskListInProc[GLCount].TITP_actionTp:=GLxmlTskInPr.Attributes['tipActTp'];
            FCGtskListInProc[GLCount].TITP_phaseTp:=GLxmlTskInPr.Attributes['tipPhase'];
            FCGtskListInProc[GLCount].TITP_ctldType:=GLxmlTskInPr.Attributes['tipTgtTp'];
            FCGtskListInProc[GLCount].TITP_ctldFac:=GLxmlTskInPr.Attributes['tipTgtFac'];
            FCGtskListInProc[GLCount].TITP_ctldIdx:=GLxmlTskInPr.Attributes['tipTgtIdx'];
            FCGtskListInProc[GLcount].TITP_timeOrg:=GLxmlTskInPr.Attributes['tipTimeOrg'];
            FCGtskListInProc[GLCount].TITP_duration:=GLxmlTskInPr.Attributes['tipDura'];
            FCGtskListInProc[GLCount].TITP_interval:=GLxmlTskInPr.Attributes['tipInterv'];
            FCGtskListInProc[GLCount].TITP_orgType:=GLxmlTskInPr.Attributes['tipOrgTp'];
            FCGtskListInProc[GLCount].TITP_orgIdx:=GLxmlTskInPr.Attributes['tipOrgIdx'];
            FCGtskListInProc[GLCount].TITP_destType:=GLxmlTskInPr.Attributes['tipDestTp'];
            FCGtskListInProc[GLCount].TITP_destIdx:=GLxmlTskInPr.Attributes['tipDestIdx'];
            FCGtskListInProc[GLCount].TITP_regIdx:=GLxmlTskInPr.Attributes['tipRegIdx'];
            FCGtskListInProc[GLCount].TITP_velCruise:=GLxmlTskInPr.Attributes['tipVelCr'];
            FCGtskListInProc[GLCount].TITP_timeToCruise:=GLxmlTskInPr.Attributes['tipTimeTcr'];
            FCGtskListInProc[GLCount].TITP_timeDecel:=GLxmlTskInPr.Attributes['tipTimeTdec'];
            FCGtskListInProc[GLCount].TITP_time2xfert:=GLxmlTskInPr.Attributes['tipTime2Xfrt'];
            FCGtskListInProc[GLCount].TITP_time2xfert2decel:=GLxmlTskInPr.Attributes['tipTime2XfrtDec'];
            FCGtskListInProc[GLCount].TITP_velFinal:=GLxmlTskInPr.Attributes['tipVelFin'];
            FCGtskListInProc[GLCount].TITP_timeToFinal:=GLxmlTskInPr.Attributes['tipTimeTfin'];
            FCGtskListInProc[GLCount].TITP_accelbyTick:=GLxmlTskInPr.Attributes['tipAccelBtick'];
            FCGtskListInProc[GLcount].TITP_usedRMassV:=GLxmlTskInPr.Attributes['tipUsedRM'];
            FCGtskListInProc[GLcount].TITP_str1:=GLxmlTskInPr.Attributes['tipStr1'];
            FCGtskListInProc[GLcount].TITP_str2:=GLxmlTskInPr.Attributes['tipStr2'];
            FCGtskListInProc[GLcount].TITP_int1:=GLxmlTskInPr.Attributes['tipInt1'];
            GLxmlTskInPr:=GLxmlTskInPr.NextSibling;
         end; {.while GLxmlGamItmTskInPr<>nil}
      end; {.if GLxmlGamItmTskInPr<>nil}
      {.read all surveyed resources}
      setlength(FCRplayer.P_surveyedResourceSpots, 1);
      GLxmlItm:=FCWinMain.FCXMLsave.DocumentElement.ChildNodes.FindNode('gfSurveyedResourceSpots');
      if GLxmlItm<>nil then
      begin
         GLcount:=0;
         GLxmlSurveyRsrc:=GLxmlItm.ChildNodes.First;
         while GLxmlSurveyRsrc<>nil do
         begin
            inc(GLcount);
            SetLength(FCRplayer.P_surveyedResourceSpots, GLcount+1);
            FCRplayer.P_surveyedResourceSpots[GLcount].SRS_orbitalObject_SatelliteToken:=GLxmlSurveyRsrc.Attributes['oobj'];
            FCRplayer.P_surveyedResourceSpots[GLcount].SRS_starSystem:=GLxmlSurveyRsrc.Attributes['ssysIdx'];
            FCRplayer.P_surveyedResourceSpots[GLcount].SRS_star:=GLxmlSurveyRsrc.Attributes['starIdx'];
            FCRplayer.P_surveyedResourceSpots[GLcount].SRS_orbitalObject:=GLxmlSurveyRsrc.Attributes['oobjIdx'];
            FCRplayer.P_surveyedResourceSpots[GLcount].SRS_satellite:=GLxmlSurveyRsrc.Attributes['satIdx'];
            if (
               (FCRplayer.P_surveyedResourceSpots[GLcount].SRS_orbitalObject_SatelliteToken<>'')
               and
               (FCRplayer.P_surveyedResourceSpots[GLcount].SRS_satellite=0)
               and ( FCDduStarSystem[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_starSystem].
                        SS_stars[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_star].
                        S_orbitalObjects[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_orbitalObject].OO_dbTokenId=FCRplayer.P_surveyedResourceSpots[GLcount].SRS_orbitalObject_SatelliteToken
                  )
               )
               or (
                  (FCRplayer.P_surveyedResourceSpots[GLcount].SRS_orbitalObject_SatelliteToken<>'')
                  and
                  (FCRplayer.P_surveyedResourceSpots[GLcount].SRS_satellite>0)
                  and ( FCDduStarSystem[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_starSystem].
                           SS_stars[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_star].
                           S_orbitalObjects[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_orbitalObject].
                           OO_satellitesList[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_satellite].OO_dbTokenId=FCRplayer.P_surveyedResourceSpots[GLcount].SRS_orbitalObject_SatelliteToken
                     )
               ) then
            begin
               if FCRplayer.P_surveyedResourceSpots[GLcount].SRS_satellite=0
               then SetLength(
                  FCRplayer.P_surveyedResourceSpots[GLcount].SRS_surveyedRegions
                  ,length(
                     FCDduStarSystem[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_starSystem].
                        SS_stars[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_star].
                        S_orbitalObjects[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_orbitalObject].OO_regions
                     )+1
                  )
               else if FCRplayer.P_surveyedResourceSpots[GLcount].SRS_satellite>0
               then SetLength(
                  FCRplayer.P_surveyedResourceSpots[GLcount].SRS_surveyedRegions
                  ,length(
                     FCDduStarSystem[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_starSystem].
                        SS_stars[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_star].
                        S_orbitalObjects[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_orbitalObject].
                        OO_satellitesList[FCRplayer.P_surveyedResourceSpots[GLcount].SRS_satellite].OO_regions
                     )+1
                  );
               GLxmlSurveyRegion:=GLxmlSurveyRsrc.ChildNodes.First;
               while GLxmlSurveyRegion<>nil do
               begin
                  GLsubCnt:=GLxmlSurveyRegion.Attributes['regionIdx'];
                  GLsubCnt1:=0;
                  GLxmlSurveyRSpot:=GLxmlSurveyRegion.ChildNodes.First;
                  while GLxmlSurveyRSpot<>nil do
                  begin
                     inc(GLsubCnt1);
                     SetLength(FCRplayer.P_surveyedResourceSpots[GLcount].SRS_surveyedRegions[GLsubCnt].SR_ResourceSpots, GLsubCnt1+1);
                     GLenumIndex:=GetEnumValue(TypeInfo(TFCEduResourceSpotTypes), GLxmlSurveyRSpot.Attributes['spotType'] );
                     FCRplayer.P_surveyedResourceSpots[GLcount].SRS_surveyedRegions[GLsubCnt].SR_ResourceSpots[GLsubCnt1].RS_type:=TFCEduResourceSpotTypes(GLenumIndex);
                     if GLenumIndex=-1
                     then raise Exception.Create('bad gamesave loading w/rsrc spot type: '+GLxmlSurveyRSpot.Attributes['spotType'])
                     else if GLenumIndex>0 then
                     begin
                        FCRplayer.P_surveyedResourceSpots[GLcount].SRS_surveyedRegions[GLsubCnt].SR_ResourceSpots[GLsubCnt1].RS_meanQualityCoefficient:=GLxmlSurveyRSpot.Attributes['meanQualCoef'];
                        FCRplayer.P_surveyedResourceSpots[GLcount].SRS_surveyedRegions[GLsubCnt].SR_ResourceSpots[GLsubCnt1].RS_spotSizeCurrent:=GLxmlSurveyRSpot.Attributes['spotSizCurr'];
                        FCRplayer.P_surveyedResourceSpots[GLcount].SRS_surveyedRegions[GLsubCnt].SR_ResourceSpots[GLsubCnt1].RS_spotSizeMax:=GLxmlSurveyRSpot.Attributes['spotSizeMax'];
                        if FCRplayer.P_surveyedResourceSpots[GLcount].SRS_surveyedRegions[GLsubCnt].SR_ResourceSpots[GLsubCnt1].RS_type=rstOreField then
                        begin
                           FCRplayer.P_surveyedResourceSpots[GLcount].SRS_surveyedRegions[GLsubCnt].SR_ResourceSpots[GLsubCnt1].RS_tOFiCarbonaceous:=GLxmlSurveyRSpot.Attributes['oreCarbo'];
                           FCRplayer.P_surveyedResourceSpots[GLcount].SRS_surveyedRegions[GLsubCnt].SR_ResourceSpots[GLsubCnt1].RS_tOFiMetallic:=GLxmlSurveyRSpot.Attributes['oreMetal'];
                           FCRplayer.P_surveyedResourceSpots[GLcount].SRS_surveyedRegions[GLsubCnt].SR_ResourceSpots[GLsubCnt1].RS_tOFiRare:=GLxmlSurveyRSpot.Attributes['oreRare'];
                           FCRplayer.P_surveyedResourceSpots[GLcount].SRS_surveyedRegions[GLsubCnt].SR_ResourceSpots[GLsubCnt1].RS_tOFiUranium:=GLxmlSurveyRSpot.Attributes['oreUra'];
                        end;
                     end;
                     GLxmlSurveyRSpot:=GLxmlSurveyRSpot.NextSibling;
                  end;
                  GLxmlSurveyRegion:=GLxmlSurveyRegion.NextSibling;
               end;
            end
            else raise Exception.Create('universe database is not compatible with the current save game file');
            GLxmlSurveyRsrc:=GLxmlSurveyRsrc.NextSibling;
         end;
      end; //==END== if GLxmlItm<>nil then... for surveyed resources ==//
      {.read "CSM" section}
      GLxmlItm:=FCWinMain.FCXMLsave.DocumentElement.ChildNodes.FindNode('gfCSM');
      if GLxmlItm<>nil
      then
      begin
         GLcount:=0;
         GLxmlCSMpL:=GLxmlItm.ChildNodes.First;
         SetLength(FCGcsmPhList, 1);
         while GLxmlCSMpL<>nil do
         begin
            SetLength(FCGcsmPhList, length(FCGcsmPhList)+1);
            inc(GLcount);
            FCGcsmPhList[GLcount].CSMPS_ProcessAtTick:=GLxmlCSMpL.Attributes['csmTick'];
            GLphFac:=0;
            GLphFacOld:=-1;
            GLxmlCSMpLsub:=GLxmlCSMpL.ChildNodes.First;
            while GLxmlCSMpLsub<>nil do
            begin
               GLphFac:=GLxmlCSMpLsub.Attributes['fac'];
               if GLphFac<>GLphFacOld
               then
               begin
                  GLphFacOld:=GLphFac;
                  SetLength(FCGcsmPhList[GLcount].CSMPS_colonies[GLphFac], 1);
                  GLphItm:=0;
               end;
               SetLength(FCGcsmPhList[GLcount].CSMPS_colonies[GLphFac], length(FCGcsmPhList[GLcount].CSMPS_colonies[GLphFac])+1);
               inc(GLphItm);
               FCGcsmPhList[GLcount].CSMPS_colonies[GLphFac, GLphItm]:=GLxmlCSMpLsub.Attributes['colony'];
               GLxmlCSMpLsub:=GLxmlCSMpLsub.NextSibling;
            end;
            GLxmlCSMpL:=GLxmlCSMpL.NextSibling;
         end; //==END== GLxmlCSMpL<>nil ==//
      end; //==END== if GLxmlItm<>nil for CSM ==//
      {.entities section}
      FCMdG_Entities_Clear;
      GLxmlEntRoot:=FCWinMain.FCXMLsave.DocumentElement.ChildNodes.FindNode('gfEntities');
      if GLxmlEntRoot<>nil
      then
      begin
         GLentCnt:=0;
         GLxmlEnt:=GLxmlEntRoot.ChildNodes.First;
         while GLxmlEnt<>nil do
         begin
            FCentities[GLentCnt].E_token:=GLxmlEnt.Attributes['token'];
            FCentities[GLentCnt].E_facLvl:=GLxmlEnt.Attributes['lvl'];
            FCentities[GLentCnt].E_bureau:=GLxmlEnt.Attributes['bur'];
            FCentities[GLentCnt].E_corrupt:=GLxmlEnt.Attributes['corr'];
            FCentities[GLentCnt].E_hqHigherLvl:=GLxmlEnt.Attributes['hqHlvl'];
            FCentities[GLentCnt].E_uc:=GLxmlEnt.Attributes['UCrve'];
            GLxmlEntSubRoot:=GLxmlEnt.ChildNodes.First;
            SetLength(FCentities[GLentCnt].E_spU, 1);
            SetLength(FCentities[GLentCnt].E_col,1);
            SetLength(FCentities[GLentCnt].E_spm,1);
            while GLxmlEntSubRoot<>nil do
            begin
               if GLxmlEntSubRoot.NodeName='entOwnSpU'
               then
               begin
                  GLcount:=0;
                  GLxmlSpOwn:=GLxmlEntSubRoot.ChildNodes.First;
                  while GLxmlSpOwn<>nil do
                  begin
                     SetLength(FCentities[GLentCnt].E_spU, length(FCentities[GLentCnt].E_spU)+1);
                     inc(GLcount);
                     FCentities[GLentCnt].E_spU[GLcount].SU_token:=GLxmlSpOwn.Attributes['tokenId'];
                     FCentities[GLentCnt].E_spU[GLcount].SU_name:=GLxmlSpOwn.Attributes['tokenName'];
                     FCentities[GLentCnt].E_spU[GLcount].SU_designToken:=GLxmlSpOwn.Attributes['desgnId'];
                     FCentities[GLentCnt].E_spU[GLcount].SU_locationStarSystem:=GLxmlSpOwn.Attributes['ssLoc'];
                     FCentities[GLentCnt].E_spU[GLcount].SU_locationStar:=GLxmlSpOwn.Attributes['stLoc'];
                     FCentities[GLentCnt].E_spU[GLcount].SU_locationOrbitalObject:=GLxmlSpOwn.Attributes['oobjLoc'];
                     FCentities[GLentCnt].E_spU[GLcount].SU_locationSatellite:=GLxmlSpOwn.Attributes['satLoc'];
                     FCentities[GLentCnt].E_spU[GLcount].SU_linked3dObject:=GLxmlSpOwn.Attributes['TdObjIdx'];
                     FCentities[GLentCnt].E_spU[GLcount].SU_locationViewX:=GLxmlSpOwn.Attributes['xLoc'];
                     FCentities[GLentCnt].E_spU[GLcount].SU_locationViewZ:=GLxmlSpOwn.Attributes['zLoc'];
                     GLdock:=GLxmlSpOwn.Attributes['docked'];
                     if GLdock>0
                     then
                     begin
                        SetLength(FCentities[GLentCnt].E_spU[GLcount].SU_dockedSpaceUnits, GLdock+1);
                        GLsubCnt:=1;
                        GLxmlDock:=GLxmlSpOwn.ChildNodes.First;
                        while GLsubCnt<=GLdock do
                        begin
                           FCentities[GLentCnt].E_spU[GLcount].SU_dockedSpaceUnits[GLsubCnt].SUDL_index:=GLxmlDock.Attributes['index'];
                           inc(GLsubCnt);
                           GLxmlDock:=GLxmlDock.NextSibling;
                        end;
                     end;
                     FCentities[GLentCnt].E_spU[GLcount].SU_assignedTask:=GLxmlSpOwn.Attributes['taskId'];
                     FCentities[GLentCnt].E_spU[GLcount].SU_status:=GLxmlSpOwn.Attributes['status'];
                     FCentities[GLentCnt].E_spU[GLcount].SU_deltaV:=GLxmlSpOwn.Attributes['dV'];
                     FCentities[GLentCnt].E_spU[GLcount].SU_3dVelocity:=GLxmlSpOwn.Attributes['TdMov'];
                     FCentities[GLentCnt].E_spU[GLcount].SU_reactionMass:=GLxmlSpOwn.Attributes['availRMass'];
                     GLxmlSpOwn:=GLxmlSpOwn.NextSibling;
                  end;
               end //==END== if GLxmlEntSubRoot.NodeName='entOwnSpU' ==//
               else if GLxmlEntSubRoot.NodeName='entColonies'
               then
               begin
                  GLcount:=0;
                  if assigned(FCcps)
                  then FCcps.FCM_ViabObj_Init(false);
                  GLxmlCol:=GLxmlEntSubRoot.ChildNodes.First;
                  while GLxmlCol<>nil do
                  begin
                     SetLength(FCentities[GLentCnt].E_col, length(FCentities[GLentCnt].E_col)+1);
                     inc(GLcount);
                     SetLength(FCentities[GLentCnt].E_col[GLcount].C_events, 1);
                     SetLength(FCentities[GLentCnt].E_col[GLcount].C_settlements, 1);
                     SetLength( FCentities[GLentCnt].E_col[GLcount].C_cabQueue, 1);
                     GLevCnt:=0;
                     GLsettleCnt:=0;
                     FCentities[GLentCnt].E_col[GLcount].C_name:=GLxmlCol.Attributes['prname'];
                     FCentities[GLentCnt].E_col[GLcount].C_foundationDateYear:=GLxmlCol.Attributes['fndyr'];
                     FCentities[GLentCnt].E_col[GLcount].C_foundationDateMonth:=GLxmlCol.Attributes['fndmth'];
                     FCentities[GLentCnt].E_col[GLcount].C_foundationDateDay:=GLxmlCol.Attributes['fnddy'];
                     FCentities[GLentCnt].E_col[GLcount].C_nextCSMsessionInTick:=GLxmlCol.Attributes['csmtime'];
                     FCentities[GLentCnt].E_col[GLcount].C_locationStarSystem:=GLxmlCol.Attributes['locssys'];
                     FCentities[GLentCnt].E_col[GLcount].C_locationStar:=GLxmlCol.Attributes['locstar'];
                     FCentities[GLentCnt].E_col[GLcount].C_locationOrbitalObject:=GLxmlCol.Attributes['locoobj'];
                     FCentities[GLentCnt].E_col[GLcount].C_locationSatellite:=GLxmlCol.Attributes['locsat'];
                     GLoobjRow[1]:=GLoobjRow[0];
                     GLoobjRow[2]:=GLoobjRow[0];
                     GLoobjRow[3]:=GLoobjRow[0];
                     GLoobjRow[4]:=GLoobjRow[0];
                     GLoobjRow:=FCFuF_StelObj_GetFullRow(
                        FCentities[GLentCnt].E_col[GLcount].C_locationStarSystem
                        ,FCentities[GLentCnt].E_col[GLcount].C_locationStar
                        ,FCentities[GLentCnt].E_col[GLcount].C_locationOrbitalObject
                        ,FCentities[GLentCnt].E_col[GLcount].C_locationOrbitalObject
                        );
                     if GLoobjRow[4]=0
                     then FCDduStarSystem[GLoobjRow[1]].SS_stars[GLoobjRow[2]].S_orbitalObjects[GLoobjRow[3]].OO_colonies[0]:=GLcount
                     else if GLoobjRow[4]>0
                     then FCDduStarSystem[GLoobjRow[1]].SS_stars[GLoobjRow[2]].S_orbitalObjects[GLoobjRow[3]].OO_satellitesList[GLoobjRow[4]].OO_colonies[0]:=GLcount;
                     FCentities[GLentCnt].E_col[GLcount].C_level:=TFCEdgColonyLevels(GLxmlCol.Attributes['collvl']-1);
                     FCentities[GLentCnt].E_col[GLcount].C_hqPresence:=GLxmlCol.Attributes['hqpresence'];
                     FCentities[GLentCnt].E_col[GLcount].C_cohesion:=GLxmlCol.Attributes['dcohes'];
                     FCentities[GLentCnt].E_col[GLcount].C_security:=GLxmlCol.Attributes['dsecu'];
                     FCentities[GLentCnt].E_col[GLcount].C_tension:=GLxmlCol.Attributes['dtens'];
                     FCentities[GLentCnt].E_col[GLcount].C_instruction:=GLxmlCol.Attributes['dedu'];
                     FCentities[GLentCnt].E_col[GLcount].C_csmHousing_PopulationCapacity:=GLxmlCol.Attributes['csmPCAP'];
                     FCentities[GLentCnt].E_col[GLcount].C_csmHousing_SpaceLevel:=GLxmlCol.Attributes['csmSPL'];
                     FCentities[GLentCnt].E_col[GLcount].C_csmHousing_QualityOfLife:=GLxmlCol.Attributes['csmQOL'];
                     FCentities[GLentCnt].E_col[GLcount].C_csmHealth_healthLevel:=GLxmlCol.Attributes['csmHEAL'];
                     FCentities[GLentCnt].E_col[GLcount].C_csmEnergy_consumption:=GLxmlCol.Attributes['csmEnCons'];
                     FCentities[GLentCnt].E_col[GLcount].C_csmEnergy_generation:=GLxmlCol.Attributes['csmEnGen'];
                     FCentities[GLentCnt].E_col[GLcount].C_csmEnergy_StorageCurrent:=GLxmlCol.Attributes['csmEnStorCurr'];
                     FCentities[GLentCnt].E_col[GLcount].C_csmEnergy_StorageMax:=GLxmlCol.Attributes['csmEnStorMax'];
                     FCentities[GLentCnt].E_col[GLcount].C_economicIndustrialOutput:=GLxmlCol.Attributes['eiOut'];
                     GLxmlColsub:=GLxmlCol.ChildNodes.First;
                     while GLxmlColsub<>nil do
                     begin
                        {.colony population}
                        if GLxmlColsub.NodeName='colPopulation'
                        then
                        begin
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_total:=GLxmlColsub.Attributes['popTtl'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_meanAge:=GLxmlColsub.Attributes['popMeanAge'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_deathRate:=GLxmlColsub.Attributes['popDRate'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_deathStack:=GLxmlColsub.Attributes['popDStack'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_birthRate:=GLxmlColsub.Attributes['popBRate'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_birthStack:=GLxmlColsub.Attributes['popBStack'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classColonist:=GLxmlColsub.Attributes['popColon'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classColonistAssigned:=GLxmlColsub.Attributes['popColonAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classAerOfficer:=GLxmlColsub.Attributes['popOff'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classAerOfficerAssigned:=GLxmlColsub.Attributes['popOffAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classAerMissionSpecialist:=GLxmlColsub.Attributes['popMisSpe'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classAerMissionSpecialistAssigned:=GLxmlColsub.Attributes['popMisSpeAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classBioBiologist:=GLxmlColsub.Attributes['popBiol'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classBioBiologistAssigned:=GLxmlColsub.Attributes['popBiolAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classBioDoctor:=GLxmlColsub.Attributes['popDoc'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classBioDoctorAssigned:=GLxmlColsub.Attributes['popDocAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classIndTechnician:=GLxmlColsub.Attributes['popTech'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classIndTechnicianAssigned:=GLxmlColsub.Attributes['popTechAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classIndEngineer:=GLxmlColsub.Attributes['popEng'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classIndEngineerAssigned:=GLxmlColsub.Attributes['popEngAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classMilSoldier:=GLxmlColsub.Attributes['popSold'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classMilSoldierAssigned:=GLxmlColsub.Attributes['popSoldAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classMilCommando:=GLxmlColsub.Attributes['popComm'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classMilCommandoAssigned:=GLxmlColsub.Attributes['popCommAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classPhyPhysicist:=GLxmlColsub.Attributes['popPhys'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classPhyPhysicistAssigned:=GLxmlColsub.Attributes['popPhysAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classPhyAstrophysicist:=GLxmlColsub.Attributes['popAstro'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classPhyAstrophysicistAssigned:=GLxmlColsub.Attributes['popAstroAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classEcoEcologist:=GLxmlColsub.Attributes['popEcol'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classEcoEcologistAssigned:=GLxmlColsub.Attributes['popEcolAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classEcoEcoformer:=GLxmlColsub.Attributes['popEcof'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classEcoEcoformerAssigned:=GLxmlColsub.Attributes['popEcofAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classAdmMedian:=GLxmlColsub.Attributes['popMedian'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classAdmMedianAssigned:=GLxmlColsub.Attributes['popMedianAssign'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classRebels:=GLxmlColsub.Attributes['popRebels'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_classMilitia:=GLxmlColsub.Attributes['popMilitia'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_CWPtotal:=GLxmlColsub.Attributes['wcpTotal'];
                           FCentities[GLentCnt].E_col[GLcount].C_population.CP_CWPassignedPeople:=GLxmlColsub.Attributes['wcpAssignPpl'];
                        end
                        {.colony events}
                        else if GLxmlColsub.NodeName='colEvent' then
                        begin
                           SetLength(FCentities[GLentCnt].E_col[GLcount].C_events, length(FCentities[GLentCnt].E_col[GLcount].C_events)+1);
                           inc(GLevCnt);
                           GLenumIndex:=GetEnumValue(TypeInfo(TFCEdgColonyEvents), GLxmlColsub.Attributes['token'] );
                           FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_type:=TFCEdgColonyEvents(GLenumIndex);
                           if GLenumIndex=-1
                           then raise Exception.Create('bad gamesave loading w/CSM event type: '+GLxmlColsub.Attributes['token']) ;
                           FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_isResident:=GLxmlColsub.Attributes['isres'];
                           FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_durationWeeks:=GLxmlColsub.Attributes['duration'];
                           FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_level:=GLxmlColsub.Attributes['level'];
                           case FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_type of
                              ceColonyEstablished:
                              begin
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tCEstTensionMod:=GLxmlColsub.Attributes['modTension'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tCEstSecurityMod:=GLxmlColsub.Attributes['modSecurity'];
                              end;

                              ceUnrest, ceUnrest_Recovering:
                              begin
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tCUnEconomicIndustrialOutputMod:=GLxmlColsub.Attributes['modEcoInd'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tCUnTensionMod:=GLxmlColsub.Attributes['modTension'];
                              end;

                              ceSocialDisorder, ceSocialDisorder_Recovering:
                              begin
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tSDisEconomicIndustrialOutputMod:=GLxmlColsub.Attributes['modEcoInd'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tSDisTensionMod:=GLxmlColsub.Attributes['modTension'];
                              end;

                              ceUprising, ceUprising_Recovering:
                              begin
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tUpEconomicIndustrialOutputMod:=GLxmlColsub.Attributes['modEcoInd'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tUpTensionMod:=GLxmlColsub.Attributes['modTension'];
                              end;

                              ceDissidentColony: ;

                              ceHealthEducationRelation: FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tHERelEducationMod:=GLxmlColsub.Attributes['modInstruction'];

                              ceGovernmentDestabilization, ceGovernmentDestabilization_Recovering: FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tGDestCohesionMod:=GLxmlColsub.Attributes['modCohesion'];

                              ceOxygenProductionOverload: FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tOPOvPercentPopulationNotSupported:=GLxmlColsub.Attributes['percPopNotSupported'];

                              ceOxygenShortage, ceOxygenShortage_Recovering:
                              begin
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tOShPercentPopulationNotSupportedAtCalculation:=GLxmlColsub.Attributes['percPopNotSupAtCalc'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tOShEconomicIndustrialOutputMod:=GLxmlColsub.Attributes['modEcoInd'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tOShTensionMod:=GLxmlColsub.Attributes['modTension'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tOShHealthMod:=GLxmlColsub.Attributes['modHealth'];
                              end;

                              ceWaterProductionOverload: FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tWPOvPercentPopulationNotSupported:=GLxmlColsub.Attributes['percPopNotSupported'];

                              ceWaterShortage, ceWaterShortage_Recovering:
                              begin
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tWShPercentPopulationNotSupportedAtCalculation:=GLxmlColsub.Attributes['percPopNotSupAtCalc'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tWShEconomicIndustrialOutputMod:=GLxmlColsub.Attributes['modEcoInd'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tWShTensionMod:=GLxmlColsub.Attributes['modTension'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tWShHealthMod:=GLxmlColsub.Attributes['modHealth'];
                              end;

                              ceFoodProductionOverload: FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tFPOvPercentPopulationNotSupported:=GLxmlColsub.Attributes['percPopNotSupported'];

                              ceFoodShortage, ceFoodShortage_Recovering:
                              begin
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tFShPercentPopulationNotSupportedAtCalculation:=GLxmlColsub.Attributes['percPopNotSupAtCalc'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tFShEconomicIndustrialOutputMod:=GLxmlColsub.Attributes['modEcoInd'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tFShTensionMod:=GLxmlColsub.Attributes['modTension'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tFShHealthMod:=GLxmlColsub.Attributes['modHealth'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tFShDirectDeathPeriod:=GLxmlColsub.Attributes['directDeathPeriod'];
                                 FCentities[GLentCnt].E_col[GLcount].C_events[GLevCnt].CCSME_tFShDeathFractionalValue:=GLxmlColsub.Attributes['deathFracValue'];
                              end;
                           end; //==END== case FCentities[GLentCnt].E_col[GLcount].COL_evList[GLevCnt].CSMEV_token of ==//
                        end
                        {.colony settlements}
                        else if GLxmlColsub.NodeName='colSettlement' then
                        begin
                           inc(GLsettleCnt);
                           SetLength(FCentities[GLentCnt].E_col[GLcount].C_settlements, GLsettleCnt+1);
                           SetLength(FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures, 1);
                           SetLength( FCentities[GLentCnt].E_col[GLcount].C_cabQueue, length( FCentities[GLentCnt].E_col[GLcount].C_cabQueue )+1 );
                           FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_name:=GLxmlColsub.Attributes['name'];
                           GLenumIndex:=GetEnumValue(TypeInfo(TFCEdgSettlements), GLxmlColsub.Attributes['type'] );
                           FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_settlement:=TFCEdgSettlements(GLenumIndex);
                           if GLenumIndex=-1
                           then raise Exception.Create('bad gamesave loading w/settlement type: '+GLxmlColsub.Attributes['type']) ;
                           FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_level:=GLxmlColsub.Attributes['level'];
                           FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_locationRegion:=GLxmlColsub.Attributes['region'];
                           GLregionIdx:=FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_locationRegion;
                           if GLoobjRow[4]=0 then
                           begin
                              FCDduStarSystem[GLoobjRow[1]].SS_stars[GLoobjRow[2]].S_orbitalObjects[GLoobjRow[3]].OO_regions[GLregionIdx].OOR_settlementEntity:=GLentCnt;
                              FCDduStarSystem[GLoobjRow[1]].SS_stars[GLoobjRow[2]].S_orbitalObjects[GLoobjRow[3]].OO_regions[GLregionIdx].OOR_settlementColony:=GLcount;
                              FCDduStarSystem[GLoobjRow[1]].SS_stars[GLoobjRow[2]].S_orbitalObjects[GLoobjRow[3]].OO_regions[GLregionIdx].OOR_settlementIndex:=GLsettleCnt;
                           end
                           else if GLoobjRow[4]>0 then
                           begin
                              FCDduStarSystem[GLoobjRow[1]].SS_stars[GLoobjRow[2]].S_orbitalObjects[GLoobjRow[3]].OO_satellitesList[GLoobjRow[4]].OO_regions[GLregionIdx].OOR_settlementEntity:=GLentCnt;
                              FCDduStarSystem[GLoobjRow[1]].SS_stars[GLoobjRow[2]].S_orbitalObjects[GLoobjRow[3]].OO_satellitesList[GLoobjRow[4]].OO_regions[GLregionIdx].OOR_settlementColony:=GLcount;
                              FCDduStarSystem[GLoobjRow[1]].SS_stars[GLoobjRow[2]].S_orbitalObjects[GLoobjRow[3]].OO_satellitesList[GLoobjRow[4]].OO_regions[GLregionIdx].OOR_settlementIndex:=GLsettleCnt;
                           end;
                           GLinfCnt:=0;
                           GLxmlInfra:=GLxmlColsub.ChildNodes.First;
                           while GLxmlInfra<>nil do
                           begin
                              SetLength( FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures, length( FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures )+1 );
                              inc(GLinfCnt);
                              FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_token:=GLxmlInfra.Attributes['token'];
                              FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_level:=GLxmlInfra.Attributes['level'];
                              GLenumIndex:=GetEnumValue(TypeInfo(TFCEdgInfrastructureStatus), GLxmlInfra.Attributes['status'] );
                              FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_status:=TFCEdgInfrastructureStatus(GLenumIndex);
                              if GLenumIndex=-1
                              then raise Exception.Create('bad gamesave loading w/infra status: '+GLxmlInfra.Attributes['status']);
                              FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_cabDuration:=GLxmlInfra.Attributes['CABduration'];
                              FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_cabWorked:=GLxmlInfra.Attributes['CABworked'];
                              FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_powerConsumption:=GLxmlInfra.Attributes['powerCons'];
                              FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_powerGeneratedFromCustomEffect:=GLxmlInfra.Attributes['powerGencFx'];
                              GLenumIndex:=GetEnumValue(TypeInfo(TFCEdipFunctions), GLxmlInfra.Attributes['Func'] );
                              FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_function:=TFCEdipFunctions(GLenumIndex);
                              if GLenumIndex=-1
                              then raise Exception.Create('bad gamesave loading w/infra function: '+GLxmlInfra.Attributes['Func']);
                              case FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_function of
                                 fEnergy: FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fEnOutput:=GLxmlInfra.Attributes['energyOut'];

                                 fHousing:
                                 begin
                                    FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fHousPopulationCapacity:=GLxmlInfra.Attributes['PCAP'];
                                    FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fHousQualityOfLife:=GLxmlInfra.Attributes['QOL'];
                                    FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fHousCalculatedVolume:=GLxmlInfra.Attributes['vol'];
                                    FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fHousCalculatedSurface:=GLxmlInfra.Attributes['surf'];
                                 end;

                                 fIntelligence:;

                                 fMiscellaneous:;

                                 fProduction:
                                 begin
                                    FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fProdSurveyedSpot:=GLxmlInfra.Attributes['surveyedSpot'];
                                    FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fProdSurveyedRegion:=GLxmlInfra.Attributes['surveyedRegion'];
                                    FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fProdResourceSpot:=GLxmlInfra.Attributes['resourceSpot'];
                                    GLsubCnt:=0;
                                    GLxmlProdMode:=GLxmlInfra.ChildNodes.First;
                                    while GLxmlProdMode<>nil do
                                    begin
                                       inc(GLsubCnt);
                                       GLenumIndex:=GetEnumValue(TypeInfo(TFCEdipProductionModes), GLxmlProdMode.Attributes['prodModeType'] );
                                       FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fProdProductionMode[GLsubCnt].PM_type:=TFCEdipProductionModes(GLenumIndex);
                                       if GLenumIndex=-1
                                       then raise Exception.Create('bad gamesave loading w/infra prod mode type: '+GLxmlProdMode.Attributes['prodModeType']);
                                       FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fProdProductionMode[GLsubCnt].PM_isDisabled:=GLxmlProdMode.Attributes['isDisabled'];
                                       FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fProdProductionMode[GLsubCnt].PM_energyConsumption:=GLxmlProdMode.Attributes['energyCons'];
                                       FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fProdProductionMode[GLsubCnt].PM_matrixItemMax:=GLxmlProdMode.Attributes['matrixItemMax'];
                                       GLsubCnt1:=0;
                                       GLxmlMatrixItem:=GLxmlProdMode.ChildNodes.First;
                                       while GLxmlMatrixItem<>nil do
                                       begin
                                          inc(GLsubCnt1);
                                          FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fProdProductionMode[GLsubCnt].PM_linkedColonyMatrixItems[GLsubCnt1].LMII_matrixItemIndex
                                             :=GLxmlMatrixItem.Attributes['pmitmIndex'];
                                          FCentities[GLentCnt].E_col[GLcount].C_settlements[GLsettleCnt].S_infrastructures[GLinfCnt].I_fProdProductionMode[GLsubCnt].PM_linkedColonyMatrixItems[GLsubCnt1].LMII_matrixItem_ProductionModeIndex
                                             :=GLxmlMatrixItem.Attributes['pmIndex'];
                                          GLxmlMatrixItem:=GLxmlMatrixItem.NextSibling;
                                       end;
                                       GLxmlProdMode:=GLxmlProdMode.NextSibling;
                                    end;
                                 end;
                              end;
                              GLxmlInfra:=GLxmlInfra.NextSibling;
                           end; //==END== while GLxmlInfra<>nil do ==//
                        end //==END== else if GLxmlColsub.NodeName='colSettlement' ==//
                        {.colony's CAB queue}
                        else if GLxmlColsub.NodeName='colCAB'
                        then
                        begin
                           GLsettleCnt:=1;
                           while GLsettleCnt<=GLsettleMax do
                           begin
                              SetLength(FCentities[GLentCnt].E_col[GLcount].C_cabQueue[GLsettleCnt], 1);
                              inc(GLsettleCnt);
                           end;
                           GLxmlCAB:=GLxmlColsub.ChildNodes.First;
                           GLcabCnt:=0;
                           while GLxmlCAB<>nil do
                           begin
                              inc(GLcabCnt);
                              GLsettleCnt:=GLxmlCAB.Attributes['settlement'];
                              SetLength(FCentities[GLentCnt].E_col[GLcount].C_cabQueue[GLsettleCnt], GLcabCnt+1);
                              GLcabValue:=GLxmlCAB.Attributes['infraIdx'];
                              FCentities[GLentCnt].E_col[GLcount].C_cabQueue[GLsettleCnt, GLcabCnt]:=GLcabValue;
                              GLxmlCAB:=GLxmlCAB.NextSibling;
                           end;
                        end
                        {.colony's production matrix}
                        else if GLxmlColsub.NodeName='colProdMatrix'
                        then
                        begin
                           SetLength(FCentities[GLentCnt].E_col[GLcount].C_productionMatrix, 1);
                           GLprodMatrixCnt:=0;
                           GLxmlProdMatrix:=GLxmlColsub.ChildNodes.First;
                           while GLxmlProdMatrix<>nil do
                           begin
                              inc(GLprodMatrixCnt);
                              SetLength(FCentities[GLentCnt].E_col[GLcount].C_productionMatrix, GLprodMatrixCnt+1);
                              FCentities[GLentCnt].E_col[GLcount].C_productionMatrix[GLprodMatrixCnt].PM_productToken:=GLxmlProdMatrix.Attributes['token'];
                              FCentities[GLentCnt].E_col[GLcount].C_productionMatrix[GLprodMatrixCnt].PM_storageIndex:=GLxmlProdMatrix.Attributes['storIdx'];
                              GLenumIndex:=GetEnumValue(TypeInfo(TFCEdipStorageTypes), GLxmlProdMatrix.Attributes['storageType'] );
                              FCentities[GLentCnt].E_col[GLcount].C_productionMatrix[GLprodMatrixCnt].PM_storage:=TFCEdipStorageTypes(GLenumIndex);
                              if GLenumIndex=-1
                              then raise Exception.Create('bad gamesave loading w/production matrix item storage type: '+GLxmlProdMatrix.Attributes['storageType']);
                              FCentities[GLentCnt].E_col[GLcount].C_productionMatrix[GLprodMatrixCnt].PM_globalProductionFlow:=GLxmlProdMatrix.Attributes['globalProdFlow'];
                              SetLength(FCentities[GLentCnt].E_col[GLcount].C_productionMatrix[GLprodMatrixCnt].PM_productionModes, 1);
                              GLsubCnt:=0;
                              GLxmlProdMatrixSource:=GLxmlProdMatrix.ChildNodes.First;
                              while GLxmlProdMatrixSource<>nil do
                              begin
                                 inc(GLsubCnt);
                                 SetLength(FCentities[GLentCnt].E_col[GLcount].C_productionMatrix[GLprodMatrixCnt].PM_productionModes, GLsubCnt+1);
                                 FCentities[GLentCnt].E_col[GLcount].C_productionMatrix[GLprodMatrixCnt].PM_productionModes[GLsubCnt].PM_locationSettlement:=GLxmlProdMatrixSource.Attributes['locSettle'];
                                 FCentities[GLentCnt].E_col[GLcount].C_productionMatrix[GLprodMatrixCnt].PM_productionModes[GLsubCnt].PM_locationInfrastructure:=GLxmlProdMatrixSource.Attributes['locInfra'];
                                 FCentities[GLentCnt].E_col[GLcount].C_productionMatrix[GLprodMatrixCnt].PM_productionModes[GLsubCnt].PM_locationProductionModeIndex:=GLxmlProdMatrixSource.Attributes['locPModeIndex'];
                                 FCentities[GLentCnt].E_col[GLcount].C_productionMatrix[GLprodMatrixCnt].PM_productionModes[GLsubCnt].PM_isDisabledByProductionSegment:=GLxmlProdMatrixSource.Attributes['isDisabledPS'];
                                 FCentities[GLentCnt].E_col[GLcount].C_productionMatrix[GLprodMatrixCnt].PM_productionModes[GLsubCnt].PM_productionFlow:=GLxmlProdMatrixSource.Attributes['prodFlow'];
                                 GLxmlProdMatrixSource:=GLxmlProdMatrixSource.NextSibling;
                              end;
                              GLxmlProdMatrix:=GLxmlProdMatrix.NextSibling;
                           end;
                        end
                        {.colony's storage}
                        else if GLxmlColsub.NodeName='colStorage'
                        then
                        begin
                           FCentities[GLentCnt].E_col[GLcount].C_storageCapacitySolidCurrent:=GLxmlColsub.Attributes['capSolidCur'];
                           FCentities[GLentCnt].E_col[GLcount].C_storageCapacitySolidMax:=GLxmlColsub.Attributes['capSolidMax'];
                           FCentities[GLentCnt].E_col[GLcount].C_storageCapacityLiquidCurrent:=GLxmlColsub.Attributes['capLiquidCur'];
                           FCentities[GLentCnt].E_col[GLcount].C_storageCapacityLiquidMax:=GLxmlColsub.Attributes['capLiquidMax'];
                           FCentities[GLentCnt].E_col[GLcount].C_storageCapacityGasCurrent:=GLxmlColsub.Attributes['capGasCur'];
                           FCentities[GLentCnt].E_col[GLcount].C_storageCapacityGasMax:=GLxmlColsub.Attributes['capGasMax'];
                           FCentities[GLentCnt].E_col[GLcount].C_storageCapacityBioCurrent:=GLxmlColsub.Attributes['capBioCur'];
                           FCentities[GLentCnt].E_col[GLcount].C_storageCapacityBioMax:=GLxmlColsub.Attributes['capBioMax'];
                           SetLength(FCentities[GLentCnt].E_col[GLcount].C_storedProducts, 1);
                           GLstorageCnt:=0;
                           GLxmlColsub1:=GLxmlColsub.ChildNodes.First;
                           while GLxmlColsub1<>nil do
                           begin
                              inc(GLstorageCnt);
                              SetLength(FCentities[GLentCnt].E_col[GLcount].C_storedProducts, GLstorageCnt+1);
                              FCentities[GLentCnt].E_col[GLcount].C_storedProducts[GLstorageCnt].SP_token:=GLxmlColsub1.Attributes['token'];
                              FCentities[GLentCnt].E_col[GLcount].C_storedProducts[GLstorageCnt].SP_unit:=GLxmlColsub1.Attributes['unit'];
                              GLxmlColsub1:=GLxmlColsub1.NextSibling;
                           end;
                        end
                        else if GLxmlColsub.NodeName='colReserves'
                        then
                        begin
                           FCentities[GLentCnt].E_col[GLcount].C_reserveOxygen:=GLxmlColsub.Attributes['oxygen'];
                           FCentities[GLentCnt].E_col[GLcount].C_reserveFood:=GLxmlColsub.Attributes['food'];
                           SetLength( FCentities[ GLentCnt ].E_col[ GLcount ].C_reserveFoodProductsIndex, 1 );
                           GLstorageCnt:=0;
                           GLxmlColsub1:=GLxmlColsub.ChildNodes.First;
                           while GLxmlColsub1<>nil do
                           begin
                              inc(GLstorageCnt);
                              SetLength( FCentities[ GLentCnt ].E_col[ GLcount ].C_reserveFoodProductsIndex, GLstorageCnt+1 );
                              FCentities[ GLentCnt ].E_col[ GLcount ].C_reserveFoodProductsIndex[ GLstorageCnt ]:=GLxmlColsub1.Attributes['index'];
                              GLxmlColsub1:=GLxmlColsub1.NextSibling;
                           end;
                           FCentities[GLentCnt].E_col[GLcount].C_reserveWater:=GLxmlColsub.Attributes['water'];
								end;
                        GLxmlColsub:=GLxmlColsub.NextSibling;
                     end; //==END== while GLxmlColsub<>nil do ==//
                     GLxmlCol:=GLxmlCol.NextSibling;
                  end; //==END== while GLxmlCol<>nil do ==//
               end //==END== else if GLxmlEntSubRoot.NodeName='entColonies' ==//
               else if GLxmlEntSubRoot.NodeName='entSPMset'
               then
               begin
                  FCentities[GLentCnt].E_spmMcohes:=GLxmlEntSubRoot.Attributes['modCoh'];
                  FCentities[GLentCnt].E_spmMtens:=GLxmlEntSubRoot.Attributes['modTens'];
                  FCentities[GLentCnt].E_spmMsec:=GLxmlEntSubRoot.Attributes['modSec'];
                  FCentities[GLentCnt].E_spmMedu:=GLxmlEntSubRoot.Attributes['modEdu'];
                  FCentities[GLentCnt].E_spmMnat:=GLxmlEntSubRoot.Attributes['modNat'];
                  FCentities[GLentCnt].E_spmMhealth:=GLxmlEntSubRoot.Attributes['modHeal'];
                  FCentities[GLentCnt].E_spmMBur:=GLxmlEntSubRoot.Attributes['modBur'];
                  FCentities[GLentCnt].E_spmMCorr:=GLxmlEntSubRoot.Attributes['modCorr'];
                  GLcount:=0;
                  GLxmlSPMset:=GLxmlEntSubRoot.ChildNodes.First;
                  while GLxmlSPMset<>nil do
                  begin
                     SetLength(FCentities[GLentCnt].E_spm, length(FCentities[GLentCnt].E_spm)+1);
                     inc(GLcount);
                     FCentities[GLentCnt].E_spm[GLcount].SPMS_token:=GLxmlSPMset.Attributes['token'];
                     FCentities[GLentCnt].E_spm[GLcount].SPMS_duration:=GLxmlSPMset.Attributes['duration'];
                     FCentities[GLentCnt].E_spm[GLcount].SPMS_ucCost:=GLxmlSPMset.Attributes['ucCost'];
                     FCentities[GLentCnt].E_spm[GLcount].SPMS_isPolicy:=GLxmlSPMset.Attributes['ispolicy'];
                     if FCentities[GLentCnt].E_spm[GLcount].SPMS_isPolicy
                     then
                     begin
                        FCentities[GLentCnt].E_spm[GLcount].SPMS_iPtIsSet:=GLxmlSPMset.Attributes['isSet'];
                        FCentities[GLentCnt].E_spm[GLcount].SPMS_iPtAcceptanceProbability:=GLxmlSPMset.Attributes['aprob'];
                     end
                     else if not FCentities[GLentCnt].E_spm[GLcount].SPMS_isPolicy
                     then
                     begin
                        FCentities[GLentCnt].E_spm[GLcount].SPMS_iPtBeliefLevel:=GLxmlSPMset.Attributes['belieflvl'];
                        FCentities[GLentCnt].E_spm[GLcount].SPMS_iPtSpreadValue:=GLxmlSPMset.Attributes['spreadval'];
                     end;
                     GLxmlSPMset:=GLxmlSPMset.NextSibling;
                  end;
               end; //==END== if GLxmlEntSubRoot.NodeName='entSPMset' ==//
               GLxmlEntSubRoot:=GLxmlEntSubRoot.NextSibling;
            end; //==END== while GLxmlEntSubRoot<>nil do ==//
            inc(GLentCnt);
            GLxmlEnt:=GLxmlEnt.NextSibling;
         end; //==END== while GLxmlEnt<>nil do ==//
      end; //==END== if GLxmlEntRoot<>nil FOR COLONIES==//
      {.read "msgqueue" saved game item}
      setlength(FCVmsgStoTtl,1);
      setlength(FCVmsgStoMsg,1);
      GLxmlItm:=FCWinMain.FCXMLsave.DocumentElement.ChildNodes.FindNode('gfMsgQueue');
      if GLxmlItm<>nil
      then
      begin
         GLcount:=0;
         GLxmlMsg:=GLxmlItm.ChildNodes.First;
         while GLxmlMsg<>nil do
         begin
            SetLength(FCVmsgStoTtl, length(FCVmsgStoTtl)+1);
            SetLength(FCVmsgStoMsg, length(FCVmsgStoMsg)+1);
            inc(GLcount);
            FCVmsgStoTtl[GLcount]:=GLxmlMsg.Attributes['msgTitle'];
            FCVmsgStoMsg[GLcount]:=GLxmlMsg.Attributes['msgMain'];
            GLxmlMsg:=GLxmlMsg.NextSibling;
         end;
      end; {.if GLxmlGamItm<>nil}
   end //==END== if (DirectoryExists(GLcurrDir)) and (FileExists(GLcurrDir+'\'+GLcurrG)) ==//
   else FCRplayer.P_viewStarSystem:='';
   {.free the memory}
   FCWinMain.FCXMLsave.Active:=false;
   FCWinMain.FCXMLsave.FileName:='';
end;

procedure FCMdFSG_Game_Save;
{:Purpose: save the current game.
    Additions:
      -2012May24- *add: CPS - Viability thresholds.
      -2012May13- *add: CSM event: etRveFoodShortage, addition of the direct death period + death fractional value.
      -2012May12- *add: CSM event: etRveOxygenShortage, etRveWaterOverload, etRveWaterShortage, etRveFoodOverload and etRveFoodShortage.
      -2012May06- *add: CSM event: etRveOxygenOverload.
      -2012Apr29- *mod: CSM event token are saved in their full names now.
                  *mod: CSM event modifiers and data are saved according to the new changes in the data structure.
      -2012Apr15- *add: completion of colony's reserves.
      -2012Mar14- *fix: owned infrastructures - forgot to include MISC and INTELLIGENCE function for saving them and their possible specific data.
      -2012Mar13- *add: selective saving for otEcoIndustrialForce data.
      -2012Mar11- *add: viability objective: otEcoIndustrialForce.
      -2012Feb09- *add: save directly the CPS objective type.
      -2012Jan11- *add: production matrix / CPMI_storageType.
      -2012Jan04- *add: owned infrastructures / power generated by custom effect.
      -2011Dec12- *mod: owned infrastructures / production function / optimize the saving if no production mode is initialized yet (in the case when the infrastructure is in assembling/building.
      -2011Dec11- *mod: transfert the disable state for production mode of the production matrix into the owned infrastructure data structure.
      -2011Dec08- *add: owned infrastructures / production function / PM_matrixItemMax.
      -2011Nov30- *add: complete surveyed resource spot data for infrastructures.
      -2011Nov18- *add: update hardcoded resource data w/ updated data structure.
      -2011Nov07- *add: complete production mode data for owned infrastructures.
                  *add: put full function name for owned infrastuctures.
      -2011Nov01- *add: complete the production matrix.
      -2011Oct19- *add: add, in list of surveyed resources, the specificity concerning the Ore field type.
      -2011Oct17- *add: complete the production matrix saving.
      -2011Oct10- *add: list for surveyed resources.
      -2011Jul31- *add: infrastructure status istDisabledByEE.
      -2011Jul19- *add: CSM Energy module - storage data.
      -2011Jul13- *add: infrastructure consumed power.
      -2011Jul12- *add: CSM - Energy data.
      -2011Jul07- *add: colonies' production matrix.
      -2011May25- *rem: infrastructure - converted housing, useless state.
      -2011May15-	*add: colony's infrastructure - CAB worked hours.
      -2011May05- *mod: complete change of colony's storage loading/saving.
      -2011Apr26- *add: colonies' assigned population data.
                  *add: colonies' construction workforce.
      -2011Apr24- *add: energy output for Energy class infrastructures.
      -2011Apr20- *add: CPS - isEnabled.
      -2011Mar16-	*add: colonies' storages + reserves.
      -2011Mar09- *add: infrastructure's CAB duration.
                  *add: colonies' CAB queue.
      -2011Mar07- *add: converted housing infrastructures.
      -2011Feb12- *add: extra task's data.
                  *add: settlements.
      -2011Feb08- *add: full status token saving, independent of the index.
      -2011Feb01- *add: economic & industrial output.
      -2010Dec29- *add: SPM cost storage data.
      -2010Dec19- *add: entities higher hq level present in the faction.
      -2010Nov08- *add: entities UC reserve.
      -2010Nov03- *add: SPMi duration.
      -2010Oct24- *add: HQ presence data for each colony.
      -2010Oct11- *add: player's faction status of the 3 categories.
      -2010Oct07- *add: memes values + policy status.
      -2010Sep29- *add: entity's bureaucracy and corruption modifiers.
      -2010Sep22- *add: bureaucracy and corruption entities data.
                  *add: SPMi isSet data.
      -2010Sep21- *add: spm settings for entities.
      -2010Sep16- *add: entities code.
      -2010Sep07- *add: saving in specific file now, including date/time: name-yr-mth-day-h-mn.
                  *add: save current file time frame in configuration file.
      -2010Aug30- *add: CSM Phase list.
      -2010Aug19- *add: population type: militia.
      -2010Aug16- *add: population type: rebels.
      -2010Aug09- *add: CSM event duration.
      -2010Aug02- *add: CSM event health modifier.
      -2010Jul27- *add: CSM event level + economic & industrial output modifier.
      -2010Jul21- *add: csmTime data.
      -2010Jul02- *add: tasklisk string data.
      -2010Jun08- *add: space unit: include the docked sub data structure.
      -2010May30- *add: colony's population sub-datastructure.
      -2010May27- *add: csm data pcap, spl, qol and heal.
      -2010May19- *add: colony infrastructures: status.
      -2010May18- *add: colony infrastructures.
      -2010May12- *add: in process task phase data.
      -2010May10- *add: the two time2xfert data.
      -2010May05- *add: TITP_regIdx.
      -2010May04- *add: TITP_timeOrg, TITP_orgType, TITP_timeDecel, TITP_accelbyTick.
                  *mod: threads saving is disabled.
      -2010Mar31- *add: colony level.
      -2010Mar27- *add: space unit docked data.
      -2010Mar22- *add: cps time left
      -2010Mar11- *add: cps data.
      -2010Mar03- *add: owned colonies.
      -2010Jan08- *mod: change gameflow state method according to game flow changes.
      -2009Dec19- *add: player's sat location.
      -2009Dec18- *add: satellite location for owned space unit.
      -2009Nov28- *add messages queue.
      -2009Nov27- *add TITP_usedRMassV.
      -2009Nov12- *add threads.
      -2009Nov10- *add tasklist in process.
      -2009Nov09- *pause the game if FAR Colony is not in closing process, and release it
                  after.
      -2009Nov08- *add owned space units.
}
var
   GSxmlCAB
   ,GSxmlCABroot
   ,GSxmlCol
   ,GSxmlColEv
   ,GSxmlColInf
   ,GSxmlCPS
   ,GSxmlCSMpL
   ,GSxmlCSMpLsub
   ,GSxmlDock
   ,GSxmlEntRoot
   ,GSxmlEnt
   ,GSxmlItm
   ,GSxmlProdMode
   ,GSxmlMatrixItem
   ,GSxmlMsg
   ,GSxmlPop
   ,GSxmlProdMatrix
   ,GSxmlProdMatrixRoot
   ,GSxmlProdMatrixSource
   ,GSxmlReserves
   ,GSxmlReservesRoot
   ,GSxmlRoot
   ,GSxmlSettle
   ,GSxmlSPM
   ,GSxmlSpOwn
   ,GSxmlstorage
	,GSxmlstorageRoot
   ,GSxmlTskInPr
   ,GSxmlSurveyRsrc
   ,GSxmlSurveyRegion
   ,GSxmlSurveyRSpot: IXMLNode;

   GScabCount
   ,GScabMax
   ,GScount
   ,GSsubCount
   ,GSsubMax
   ,GSsubMax1
   ,GSsubCount1
   ,GSdock
   ,GSlength
   ,GSphFac
   ,GSphItm
   ,GSspuMax
   ,GSspuCnt
   ,GScolMax
   ,GScolCnt
   ,GSprodMatrixCnt
   ,GSprodMatrixMax
   ,GSsettleCnt
   ,GSsettleMax
   ,GSstorageCnt
	,GSstorageMax
   ,GSspmMax
   ,GSspmCnt
   ,GSsubL
   ,GSsubC: integer;

   GScurrDir
   ,GScurrG
   ,GSstringStore
   ,GSenumString: string;
begin
   if not FCWinMain.CloseQuery
   then FCMgTFlow_FlowState_Set(tphPAUSE);
   GScurrDir:=FCVdiPathConfigDir+'SavedGames\'+FCRplayer.P_gameName;
   GScurrG:=IntToStr(FCRplayer.P_currentTimeYear)
      +'-'+IntToStr(FCRplayer.P_currentTimeMonth)
      +'-'+IntToStr(FCRplayer.P_currentTimeDay)
      +'-'+IntToStr(FCRplayer.P_currentTimeHour)
      +'-'+IntToStr(FCRplayer.P_currentTimeMinut)
      +'.xml';
   {.create the save directory if needed}
   if not DirectoryExists(GScurrDir)
   then MkDir(GScurrDir);
   {.clear the old file if it exists}
   if FileExists(GScurrDir+'\'+GScurrG)
   then DeleteFile(pchar(GScurrDir+'\'+GScurrG));
   FCMdF_ConfigurationFile_Save(true);
   {.link and activate TXMLDocument}
   FCWinMain.FCXMLsave.Active:=true;
   {.create the root node of the saved game file}
   GSxmlRoot:=FCWinMain.FCXMLsave.AddChild('savedgfile');
   {.create "main" item}
   GSxmlItm:=GSxmlRoot.AddChild('gfMain');
   GSxmlItm.Attributes['gName']:= FCRplayer.P_gameName;
   GSxmlItm.Attributes['facAlleg']:= FCRplayer.P_allegianceFaction;
   GSxmlItm.Attributes['plyrsSSLoc']:= FCRplayer.P_viewStarSystem;
   GSxmlItm.Attributes['plyrsStLoc']:= FCRplayer.P_viewStar;
   GSxmlItm.Attributes['plyrsOObjLoc']:= FCRplayer.P_viewOrbitalObject;
   GSxmlItm.Attributes['plyrsatLoc']:=FCRplayer.P_viewSatellite;
   {.create "timeframe" item}
   GSxmlItm:=GSxmlRoot.AddChild('gfTimeFr');
   GSxmlItm.Attributes['tfTick']:= FCRplayer.P_currentTimeTick;
   GSxmlItm.Attributes['tfMin']:= FCRplayer.P_currentTimeMinut;
   GSxmlItm.Attributes['tfHr']:= FCRplayer.P_currentTimeHour;
   GSxmlItm.Attributes['tfDay']:= FCRplayer.P_currentTimeDay;
   GSxmlItm.Attributes['tfMth']:= FCRplayer.P_currentTimeMonth;
   GSxmlItm.Attributes['tfYr']:= FCRplayer.P_currentTimeYear;
   {.create "status" item}
   GSxmlItm:=GSxmlRoot.AddChild('gfStatus');
   GSxmlItm.Attributes['statEco']:=FCRplayer.P_economicStatus;
   GSxmlItm.Attributes['statEcoThr']:=FCRplayer.P_economicViabilityThreshold;
   GSxmlItm.Attributes['statSoc']:=FCRplayer.P_socialStatus;
   GSxmlItm.Attributes['statSocThr']:=FCRplayer.P_socialViabilityThreshold;
   GSxmlItm.Attributes['statSpMil']:=FCRplayer.P_militaryStatus;
   GSxmlItm.Attributes['statSpMilThr']:=FCRplayer.P_militaryViabilityThreshold;
   {.create "cps" saved game item}
   if FCcps<>nil
   then
   begin
      GSlength:=length(FCcps.CPSviabObj);
      GSxmlItm:=GSxmlRoot.AddChild('gfCPS');
      GSxmlItm.Attributes['cpsEnabled']:=FCcps.CPSisEnabled;
      GSxmlItm.Attributes['cpsCVS']:=FCcps.FCF_CVS_Get;
      GSxmlItm.Attributes['cpsTlft']:=FCcps.FCF_TimeLeft_Get(true);
      GSxmlItm.Attributes['cpsInt']:=FCcps.FCF_CredLineInterest_Get;
      GSxmlItm.Attributes['cpsCredU']:=FCcps.FCF_CredLine_Get(true, true);
      GSxmlItm.Attributes['cpsCredM']:=FCcps.FCF_CredLine_Get(false, true);
      GScount:=1;
      while GScount<=GSlength-1 do
      begin
         GSxmlCPS:=GSxmlItm.AddChild('gfViabObj');
         GSxmlCPS.Attributes['objTp']:=GetEnumName( TypeInfo( TFCEcpsoObjectiveTypes ), Integer( FCcps.CPSviabObj[GScount].CPSO_type ) );
         GSxmlCPS.Attributes['score']:=FCcps.CPSviabObj[GScount].CPSO_score;
         if FCcps.CPSviabObj[GScount].CPSO_type=otEcoIndustrialForce then
         begin
            GSxmlCPS.Attributes['product']:=FCcps.CPSviabObj[GScount].CPSO_ifProduct;
            GSxmlCPS.Attributes['threshold']:=FCcps.CPSviabObj[GScount].CPSO_ifThreshold;
         end;
         inc(GScount);
      end; {.while GScount<=GSlength-1}
   end; //==END== if FCcps<>nil ==//
   {.create "taskinprocess" saved game item}
   GSlength:=length(FCGtskListInProc);
   if GSlength>1
   then
   begin
      GSxmlItm:=GSxmlRoot.AddChild('gfTskLstinProc');
      GScount:=1;
      while GScount<=GSlength-1 do
      begin
         GSxmlTskInPr:=GSxmlItm.AddChild('gfTskInProc');
         GSxmlTskInPr.Attributes['tipEna']:=FCGtskListInProc[GScount].TITP_enabled;
         GSxmlTskInPr.Attributes['tipActTp']:=FCGtskListInProc[GScount].TITP_actionTp;
         GSxmlTskInPr.Attributes['tipPhase']:=FCGtskListInProc[GScount].TITP_phaseTp;
         GSxmlTskInPr.Attributes['tipTgtTp']:=FCGtskListInProc[GScount].TITP_ctldType;
         GSxmlTskInPr.Attributes['tipTgtFac']:=FCGtskListInProc[GScount].TITP_ctldFac;
         GSxmlTskInPr.Attributes['tipTgtIdx']:=FCGtskListInProc[GScount].TITP_ctldIdx;
         GSxmlTskInPr.Attributes['tipTimeOrg']:=FCGtskListInProc[GScount].TITP_timeOrg;
         GSxmlTskInPr.Attributes['tipDura']:=FCGtskListInProc[GScount].TITP_duration;
         GSxmlTskInPr.Attributes['tipInterv']:=FCGtskListInProc[GScount].TITP_interval;
         GSxmlTskInPr.Attributes['tipOrgTp']:=FCGtskListInProc[GScount].TITP_orgType;
         GSxmlTskInPr.Attributes['tipOrgIdx']:=FCGtskListInProc[GScount].TITP_orgIdx;
         GSxmlTskInPr.Attributes['tipDestTp']:=FCGtskListInProc[GScount].TITP_destType;
         GSxmlTskInPr.Attributes['tipDestIdx']:=FCGtskListInProc[GScount].TITP_destIdx;
         GSxmlTskInPr.Attributes['tipRegIdx']:=FCGtskListInProc[GScount].TITP_regIdx;
         GSxmlTskInPr.Attributes['tipVelCr']:=FCGtskListInProc[GScount].TITP_velCruise;
         GSxmlTskInPr.Attributes['tipTimeTcr']:=FCGtskListInProc[GScount].TITP_timeToCruise;
         GSxmlTskInPr.Attributes['tipTimeTdec']:=FCGtskListInProc[GScount].TITP_timeDecel;
         GSxmlTskInPr.Attributes['tipTime2Xfrt']:=FCGtskListInProc[GScount].TITP_time2xfert;
         GSxmlTskInPr.Attributes['tipTime2XfrtDec']:=FCGtskListInProc[GScount].TITP_time2xfert2decel;
         GSxmlTskInPr.Attributes['tipVelFin']:=FCGtskListInProc[GScount].TITP_velFinal;
         GSxmlTskInPr.Attributes['tipTimeTfin']:=FCGtskListInProc[GScount].TITP_timeToFinal;
         GSxmlTskInPr.Attributes['tipAccelBtick']:=FCGtskListInProc[GScount].TITP_accelbyTick;
         GSxmlTskInPr.Attributes['tipUsedRM']:=FCGtskListInProc[GScount].TITP_usedRMassV;
         GSxmlTskInPr.Attributes['tipStr1']:=FCGtskListInProc[GScount].TITP_str1;
         GSxmlTskInPr.Attributes['tipStr2']:=FCGtskListInProc[GScount].TITP_str1;
         GSxmlTskInPr.Attributes['tipInt1']:=FCGtskListInProc[GScount].TITP_int1;
         inc(GScount);
      end; {.while GScount<=GSlength-1}
   end; {.if GSlength>1 then... for taskinprocess}
   {.all surveyed resources}
   GSlength:=length(FCRplayer.P_surveyedResourceSpots);
   if GSlength>1 then
   begin
      GSxmlItm:=GSxmlRoot.AddChild('gfSurveyedResourceSpots');
      GScount:=1;
      while GScount<=GSlength-1 do
      begin
         GSxmlSurveyRsrc:=GSxmlItm.AddChild('gfSpotLocation');
         GSxmlSurveyRsrc.Attributes['oobj']:=FCRplayer.P_surveyedResourceSpots[GScount].SRS_orbitalObject_SatelliteToken;
         GSxmlSurveyRsrc.Attributes['ssysIdx']:=FCRplayer.P_surveyedResourceSpots[GScount].SRS_starSystem;
         GSxmlSurveyRsrc.Attributes['starIdx']:=FCRplayer.P_surveyedResourceSpots[GScount].SRS_star;
         GSxmlSurveyRsrc.Attributes['oobjIdx']:=FCRplayer.P_surveyedResourceSpots[GScount].SRS_orbitalObject;
         GSxmlSurveyRsrc.Attributes['satIdx']:=FCRplayer.P_surveyedResourceSpots[GScount].SRS_satellite;
         GSsubMax:=length(FCRplayer.P_surveyedResourceSpots[GScount].SRS_surveyedRegions)-1;
         GSsubCount:=1;
         while GSsubCount<=GSsubMax do
         begin
            GSsubMax1:=length(FCRplayer.P_surveyedResourceSpots[GScount].SRS_surveyedRegions[GSsubCount].SR_ResourceSpots)-1;
            if GSsubMax1>0 then
            begin
               GSxmlSurveyRegion:=GSxmlSurveyRsrc.AddChild('gfSpotRegion');
               GSxmlSurveyRegion.Attributes['regionIdx']:=GSsubCount;
               GSsubCount1:=1;
               while GSsubCount1<=GSsubMax1 do
               begin
                  GSxmlSurveyRSpot:=GSxmlSurveyRegion.AddChild('gfRsrcSpot');
                  GSxmlSurveyRSpot.Attributes['spotType']
                     :=GetEnumName(TypeInfo(TFCEduResourceSpotTypes), Integer(FCRplayer.P_surveyedResourceSpots[GScount].SRS_surveyedRegions[GSsubCount].SR_ResourceSpots[GSsubCount1].RS_type));
                  GSxmlSurveyRSpot.Attributes['meanQualCoef']:=FCRplayer.P_surveyedResourceSpots[GScount].SRS_surveyedRegions[GSsubCount].SR_ResourceSpots[GSsubCount1].RS_meanQualityCoefficient;
                  GSxmlSurveyRSpot.Attributes['spotSizCurr']:=FCRplayer.P_surveyedResourceSpots[GScount].SRS_surveyedRegions[GSsubCount].SR_ResourceSpots[GSsubCount1].RS_spotSizeCurrent;
                  GSxmlSurveyRSpot.Attributes['spotSizeMax']:=FCRplayer.P_surveyedResourceSpots[GScount].SRS_surveyedRegions[GSsubCount].SR_ResourceSpots[GSsubCount1].RS_spotSizeMax;
                  if FCRplayer.P_surveyedResourceSpots[GScount].SRS_surveyedRegions[GSsubCount].SR_ResourceSpots[GSsubCount1].RS_type=rstOreField then
                  begin
                     GSxmlSurveyRSpot.Attributes['oreCarbo']:=FCRplayer.P_surveyedResourceSpots[GScount].SRS_surveyedRegions[GSsubCount].SR_ResourceSpots[GSsubCount1].RS_tOFiCarbonaceous;
                     GSxmlSurveyRSpot.Attributes['oreMetal']:=FCRplayer.P_surveyedResourceSpots[GScount].SRS_surveyedRegions[GSsubCount].SR_ResourceSpots[GSsubCount1].RS_tOFiMetallic;
                     GSxmlSurveyRSpot.Attributes['oreRare']:=FCRplayer.P_surveyedResourceSpots[GScount].SRS_surveyedRegions[GSsubCount].SR_ResourceSpots[GSsubCount1].RS_tOFiRare;
                     GSxmlSurveyRSpot.Attributes['oreUra']:=FCRplayer.P_surveyedResourceSpots[GScount].SRS_surveyedRegions[GSsubCount].SR_ResourceSpots[GSsubCount1].RS_tOFiUranium;
                  end;
                  inc(GSsubCount1);
               end;
            end;
            inc(GSsubCount);
         end;
         inc(GScount);
      end; //==END== while GScount<=GSlength-1 do ==//
   end; //==END== if GSlength>1 then... for surveyed resource spots ==//
   {.create "CSM" saved game item}
   GSlength:=length(FCGcsmPhList);
   if GSlength>1
   then
   begin
      GSxmlItm:=GSxmlRoot.AddChild('gfCSM');
      GScount:=1;
      while GScount<=GSlength-1 do
      begin
         GSxmlCSMpL:=GSxmlItm.AddChild('csmPhList');
         GSxmlCSMpL.Attributes['csmTick']:=FCGcsmPhList[GScount].CSMPS_ProcessAtTick;
         GSphFac:=0;
         while GSphFac<=1 do
         begin
            GSsubL:=length(FCGcsmPhList[GScount].CSMPS_colonies[GSphFac])-1;
            GSsubC:=1;
            if GSsubL>0
            then
            begin
               while GSsubC<=GSsubL do
               begin
                  GSxmlCSMpLsub:=GSxmlCSMpL.AddChild('csmPhase');
                  GSxmlCSMpLsub.Attributes['fac']:=GSphFac;
                  GSxmlCSMpLsub.Attributes['colony']:=FCGcsmPhList[GScount].CSMPS_colonies[GSphFac, GSsubL];
                  inc(GSsubC);
               end;
            end;
            inc(GSphFac);
         end;
         inc(GScount);
      end; //==END== while GScount<=GSlength-1 ==//
   end; //==END== if GSlength>1 for CSM ==//
   {.create entities section}
   GSxmlEntRoot:=GSxmlRoot.AddChild('gfEntities');
   GScount:=0;
   while GScount<=FCCdiFactionsMax do
   begin
      GSxmlEnt:=GSxmlEntRoot.AddChild('entity');
      GSxmlEnt.Attributes['token']:=FCentities[GScount].E_token;
      GSxmlEnt.Attributes['lvl']:=FCentities[GScount].E_facLvl;
      GSxmlEnt.Attributes['bur']:=FCentities[GScount].E_bureau;
      GSxmlEnt.Attributes['corr']:=FCentities[GScount].E_corrupt;
      GSxmlEnt.Attributes['hqHlvl']:=FCentities[GScount].E_hqHigherLvl;
      GSxmlEnt.Attributes['UCrve']:=FCentities[GScount].E_uc;
      GSspuMax:=Length(FCentities[GScount].E_spU)-1;
      if GSspuMax>0
      then
      begin
         GSxmlItm:=GSxmlEnt.AddChild('entOwnSpU');
         GSspuCnt:=1;
         while GSspuCnt<=GSspuMax do
         begin
            GSdock:=length(FCentities[GScount].E_spU[GSspuCnt].SU_dockedSpaceUnits)-1;
            GSxmlSpOwn:=GSxmlItm.AddChild('entSpU');
            GSxmlSpOwn.Attributes['tokenId']:=FCentities[GScount].E_spU[GSspuCnt].SU_token;
            GSxmlSpOwn.Attributes['tokenName']:=FCentities[GScount].E_spU[GSspuCnt].SU_name;
            GSxmlSpOwn.Attributes['desgnId']:=FCentities[GScount].E_spU[GSspuCnt].SU_designToken;
            GSxmlSpOwn.Attributes['ssLoc']:=FCentities[GScount].E_spU[GSspuCnt].SU_locationStarSystem;
            GSxmlSpOwn.Attributes['stLoc']:=FCentities[GScount].E_spU[GSspuCnt].SU_locationStar;
            GSxmlSpOwn.Attributes['oobjLoc']:=FCentities[GScount].E_spU[GSspuCnt].SU_locationOrbitalObject;
            GSxmlSpOwn.Attributes['satLoc']:=FCentities[GScount].E_spU[GSspuCnt].SU_locationSatellite;
            GSxmlSpOwn.Attributes['TdObjIdx']:=FCentities[GScount].E_spU[GSspuCnt].SU_linked3dObject;
            GSxmlSpOwn.Attributes['xLoc']:=FCentities[GScount].E_spU[GSspuCnt].SU_locationViewX;
            GSxmlSpOwn.Attributes['zLoc']:=FCentities[GScount].E_spU[GSspuCnt].SU_locationViewZ;
            GSxmlSpOwn.Attributes['docked']:=GSdock;
            GSsubC:=1;
            while GSsubC<=GSdock do
            begin
               GSxmlDock:=GSxmlSpOwn.AddChild('entSpUdckd');
               GSxmlDock.Attributes['index']:=FCentities[GScount].E_spU[GSspuCnt].SU_dockedSpaceUnits[GSsubC].SUDL_index;
               inc(GSsubC);
            end;
            GSxmlSpOwn.Attributes['taskId']:=FCentities[GScount].E_spU[GSspuCnt].SU_assignedTask;
            GSxmlSpOwn.Attributes['status']:=FCentities[GScount].E_spU[GSspuCnt].SU_status;
            GSxmlSpOwn.Attributes['dV']:=FCentities[GScount].E_spU[GSspuCnt].SU_deltaV;
            GSxmlSpOwn.Attributes['TdMov']:=FCentities[GScount].E_spU[GSspuCnt].SU_3dVelocity;
            GSxmlSpOwn.Attributes['availRMass']:=FCentities[GScount].E_spU[GSspuCnt].SU_reactionMass;
            inc(GSspuCnt);
         end; {.while GSspuCnt<=GSspuMax}
      end; //==END== if GSspuMax>0 ==//
      GScolMax:=Length(FCentities[GScount].E_col)-1;
      if GScolMax>0
      then
      begin
         GSxmlItm:=GSxmlEnt.AddChild('entColonies');
         GScolCnt:=1;
         while GScolCnt<=GScolMax do
         begin
            GSxmlCol:=GSxmlItm.AddChild('entColony');
            GSxmlCol.Attributes['prname']:=FCentities[GScount].E_col[GScolCnt].C_name;
            GSxmlCol.Attributes['fndyr']:=FCentities[GScount].E_col[GScolCnt].C_foundationDateYear;
            GSxmlCol.Attributes['fndmth']:=FCentities[GScount].E_col[GScolCnt].C_foundationDateMonth;
            GSxmlCol.Attributes['fnddy']:=FCentities[GScount].E_col[GScolCnt].C_foundationDateDay;
            GSxmlCol.Attributes['csmtime']:=FCentities[GScount].E_col[GScolCnt].C_nextCSMsessionInTick;
            GSxmlCol.Attributes['locssys']:=FCentities[GScount].E_col[GScolCnt].C_locationStarSystem;
            GSxmlCol.Attributes['locstar']:=FCentities[GScount].E_col[GScolCnt].C_locationStar;
            GSxmlCol.Attributes['locoobj']:=FCentities[GScount].E_col[GScolCnt].C_locationOrbitalObject;
            GSxmlCol.Attributes['locsat']:=FCentities[GScount].E_col[GScolCnt].C_locationSatellite;
            GSxmlCol.Attributes['collvl']:=FCentities[GScount].E_col[GScolCnt].C_level;
            GSxmlCol.Attributes['hqpresence']:=FCentities[GScount].E_col[GScolCnt].C_hqPresence;
            GSxmlCol.Attributes['dcohes']:=FCentities[GScount].E_col[GScolCnt].C_cohesion;
            GSxmlCol.Attributes['dsecu']:=FCentities[GScount].E_col[GScolCnt].C_security;
            GSxmlCol.Attributes['dtens']:=FCentities[GScount].E_col[GScolCnt].C_tension;
            GSxmlCol.Attributes['dedu']:=FCentities[GScount].E_col[GScolCnt].C_instruction;
            GSxmlCol.Attributes['csmPCAP']:=FCentities[GScount].E_col[GScolCnt].C_csmHousing_PopulationCapacity;
            GSxmlCol.Attributes['csmSPL']:=FCentities[GScount].E_col[GScolCnt].C_csmHousing_SpaceLevel;
            GSxmlCol.Attributes['csmQOL']:=FCentities[GScount].E_col[GScolCnt].C_csmHousing_QualityOfLife;
            GSxmlCol.Attributes['csmHEAL']:=FCentities[GScount].E_col[GScolCnt].C_csmHealth_healthLevel;
            GSxmlCol.Attributes['csmEnCons']:=FCentities[GScount].E_col[GScolCnt].C_csmEnergy_consumption;
            GSxmlCol.Attributes['csmEnGen']:=FCentities[GScount].E_col[GScolCnt].C_csmEnergy_generation;
            GSxmlCol.Attributes['csmEnStorCurr']:=FCentities[GScount].E_col[GScolCnt].C_csmEnergy_StorageCurrent;
            GSxmlCol.Attributes['csmEnStorMax']:=FCentities[GScount].E_col[GScolCnt].C_csmEnergy_StorageMax;
            GSxmlCol.Attributes['eiOut']:=FCentities[GScount].E_col[GScolCnt].C_economicIndustrialOutput;
            {.colony population}
            GSxmlPop:=GSxmlCol.AddChild('colPopulation');
            GSxmlPop.Attributes['popTtl']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_total;
            GSxmlPop.Attributes['popMeanAge']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_meanAge;
            GSxmlPop.Attributes['popDRate']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_deathRate;
            GSxmlPop.Attributes['popDStack']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_deathStack;
            GSxmlPop.Attributes['popBRate']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_birthRate;
            GSxmlPop.Attributes['popBStack']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_birthStack;
            GSxmlPop.Attributes['popColon']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classColonist;
            GSxmlPop.Attributes['popColonAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classColonistAssigned;
            GSxmlPop.Attributes['popOff']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classAerOfficer;
            GSxmlPop.Attributes['popOffAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classAerOfficerAssigned;
            GSxmlPop.Attributes['popMisSpe']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classAerMissionSpecialist;
            GSxmlPop.Attributes['popMisSpeAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classAerMissionSpecialistAssigned;
            GSxmlPop.Attributes['popBiol']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classBioBiologist;
            GSxmlPop.Attributes['popBiolAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classBioBiologistAssigned;
            GSxmlPop.Attributes['popDoc']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classBioDoctor;
            GSxmlPop.Attributes['popDocAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classBioDoctorAssigned;
            GSxmlPop.Attributes['popTech']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classIndTechnician;
            GSxmlPop.Attributes['popTechAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classIndTechnicianAssigned;
            GSxmlPop.Attributes['popEng']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classIndEngineer;
            GSxmlPop.Attributes['popEngAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classIndEngineerAssigned;
            GSxmlPop.Attributes['popSold']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classMilSoldier;
            GSxmlPop.Attributes['popSoldAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classMilSoldierAssigned;
            GSxmlPop.Attributes['popComm']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classMilCommando;
            GSxmlPop.Attributes['popCommAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classMilCommandoAssigned;
            GSxmlPop.Attributes['popPhys']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classPhyPhysicist;
            GSxmlPop.Attributes['popPhysAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classPhyPhysicistAssigned;
            GSxmlPop.Attributes['popAstro']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classPhyAstrophysicist;
            GSxmlPop.Attributes['popAstroAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classPhyAstrophysicistAssigned;
            GSxmlPop.Attributes['popEcol']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classEcoEcologist;
            GSxmlPop.Attributes['popEcolAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classEcoEcologistAssigned;
            GSxmlPop.Attributes['popEcof']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classEcoEcoformer;
            GSxmlPop.Attributes['popEcofAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classEcoEcoformerAssigned;
            GSxmlPop.Attributes['popMedian']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classAdmMedian;
            GSxmlPop.Attributes['popMedianAssign']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classAdmMedianAssigned;
            GSxmlPop.Attributes['popRebels']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classRebels;
            GSxmlPop.Attributes['popMilitia']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_classMilitia;
            GSxmlPop.Attributes['wcpTotal']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_CWPtotal;
            GSxmlPop.Attributes['wcpAssignPpl']:=FCentities[GScount].E_col[GScolCnt].C_population.CP_CWPassignedPeople;
            {.colony events}
            GSsubL:=length(FCentities[GScount].E_col[GScolCnt].C_events);
            if GSsubL>1 then
            begin
               GSsubC:=1;
               while GSsubC<=GSsubL-1 do
               begin
                  GSxmlColEv:=GSxmlCol.AddChild('colEvent');
                  case FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_type of
                     ceColonyEstablished:
                     begin
                        GSxmlColEv.Attributes['token']:='etColEstab';
                        GSxmlColEv.Attributes['modTension']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tCEstTensionMod;
                        GSxmlColEv.Attributes['modSecurity']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tCEstSecurityMod;
                     end;

                     ceUnrest, ceUnrest_Recovering:
                     begin
                        case FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_type of
                           ceUnrest: GSxmlColEv.Attributes['token']:='etUnrest';

                           ceUnrest_Recovering: GSxmlColEv.Attributes['token']:='etUnrestRec';
                        end;
                        GSxmlColEv.Attributes['modEcoInd']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tCUnEconomicIndustrialOutputMod;
                        GSxmlColEv.Attributes['modTension']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tCUnTensionMod;
                     end;

                     ceSocialDisorder, ceSocialDisorder_Recovering:
                     begin
                        case FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_type of
                           ceSocialDisorder: GSxmlColEv.Attributes['token']:='etSocdis';

                           ceSocialDisorder_Recovering: GSxmlColEv.Attributes['token']:='etSocdisRec';
                        end;
                        GSxmlColEv.Attributes['modEcoInd']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tSDisEconomicIndustrialOutputMod;
                        GSxmlColEv.Attributes['modTension']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tSDisTensionMod;
                     end;

                     ceUprising, ceUprising_Recovering:
                     begin
                        case FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_type of
                           ceUprising: GSxmlColEv.Attributes['token']:='etUprising';

                           ceUprising_Recovering: GSxmlColEv.Attributes['token']:='etUprisingRec';
                        end;
                        GSxmlColEv.Attributes['modEcoInd']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tUpEconomicIndustrialOutputMod;
                        GSxmlColEv.Attributes['modTension']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tUpTensionMod;
                     end;

                     ceDissidentColony: GSxmlColEv.Attributes['token']:='etColDissident';

                     ceHealthEducationRelation:
                     begin
                        GSxmlColEv.Attributes['token']:='etHealthEduRel';
                        GSxmlColEv.Attributes['modInstruction']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tHERelEducationMod;
                     end;

                     ceGovernmentDestabilization, ceGovernmentDestabilization_Recovering:
                     begin
                        case FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_type of
                           ceGovernmentDestabilization: GSxmlColEv.Attributes['token']:='etGovDestab';
                           ceGovernmentDestabilization_Recovering: GSxmlColEv.Attributes['token']:='etGovDestabRec';
                        end;
                        GSxmlColEv.Attributes['modCohesion']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tGDestCohesionMod;
                     end;

                     ceOxygenProductionOverload:
                     begin
                        GSxmlColEv.Attributes['token']:='etRveOxygenOverload';
                        GSxmlColEv.Attributes['percPopNotSupported']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tOPOvPercentPopulationNotSupported;
                     end;

                     ceOxygenShortage, ceWaterShortage_Recovering:
                     begin
                        case FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_type of
                           ceOxygenShortage: GSxmlColEv.Attributes['token']:='etRveOxygenShortage';

                           ceWaterShortage_Recovering: GSxmlColEv.Attributes['token']:='etRveOxygenShortageRec';
                        end;
                        GSxmlColEv.Attributes['percPopNotSupAtCalc']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tOShPercentPopulationNotSupportedAtCalculation;
                        GSxmlColEv.Attributes['modEcoInd']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tOShEconomicIndustrialOutputMod;
                        GSxmlColEv.Attributes['modTension']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tOShTensionMod;
                        GSxmlColEv.Attributes['modHealth']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tOShHealthMod;
                     end;

                     ceWaterProductionOverload:
                     begin
                        GSxmlColEv.Attributes['token']:='etRveWaterOverload';
                        GSxmlColEv.Attributes['percPopNotSupported']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tWPOvPercentPopulationNotSupported;
                     end;

                     ceWaterShortage:
                     begin
                        case FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_type of
                           ceWaterShortage: GSxmlColEv.Attributes['token']:='etRveWaterShortage';

                           ceWaterShortage_Recovering: GSxmlColEv.Attributes['token']:='etRveWaterShortageRec';
                        end;
                        GSxmlColEv.Attributes['percPopNotSupAtCalc']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tWShPercentPopulationNotSupportedAtCalculation;
                        GSxmlColEv.Attributes['modEcoInd']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tWShEconomicIndustrialOutputMod;
                        GSxmlColEv.Attributes['modTension']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tWShTensionMod;
                        GSxmlColEv.Attributes['modHealth']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tWShHealthMod;
                     end;

                     ceFoodProductionOverload:
                     begin
                        GSxmlColEv.Attributes['token']:='etRveFoodOverload';
                        GSxmlColEv.Attributes['percPopNotSupported']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tFPOvPercentPopulationNotSupported;
                     end;

                     ceFoodShortage:
                     begin
                        case FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_type of
                           ceFoodShortage: GSxmlColEv.Attributes['token']:='etRveFoodShortage';

                           ceFoodShortage_Recovering: GSxmlColEv.Attributes['token']:='etRveFoodShortageRec';
                        end;
                        GSxmlColEv.Attributes['percPopNotSupAtCalc']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tFShPercentPopulationNotSupportedAtCalculation;
                        GSxmlColEv.Attributes['modEcoInd']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tFShEconomicIndustrialOutputMod;
                        GSxmlColEv.Attributes['modTension']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tFShTensionMod;
                        GSxmlColEv.Attributes['modHealth']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tFShHealthMod;
                        GSxmlColEv.Attributes['directDeathPeriod']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tFShDirectDeathPeriod;
                        GSxmlColEv.Attributes['deathFracValue']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_tFShDeathFractionalValue;
                     end;
                  end; //==END== case FCentities[GScount].E_col[GScolCnt].COL_evList[GSsubC].CSMEV_token of ==//
                  GSxmlColEv.Attributes['isres']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_isResident;
                  GSxmlColEv.Attributes['duration']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_durationWeeks;
                  GSxmlColEv.Attributes['level']:=FCentities[GScount].E_col[GScolCnt].C_events[GSsubC].CCSME_level;
                  inc(GSsubC);
               end; //==END== while GSsubC<=GSsubL-1 do ==//
            end; //==END== if GSsubL>1 ==//
            {.colony settlements}
            GSsettleMax:=length(FCentities[GScount].E_col[GScolCnt].C_settlements)-1;
            if GSsettleMax>0 then
            begin
               GSxmlCABroot:=nil;
               GSsettleCnt:=1;
               while GSsettleCnt<=GSsettleMax do
               begin
                  GSxmlSettle:=GSxmlCol.AddChild('colSettlement');
                  GSxmlSettle.Attributes['name']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_name;
                  case FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_settlement of
                     sSurface: GSenumString:='stSurface';
                     sSpaceSurface: GSenumString:='stSpaceSurf';
                     sSubterranean: GSenumString:='stSubterranean';
                     sSpaceBased: GSenumString:='stSpaceBased';
                  end;
                  GSxmlSettle.Attributes['type']:=GSenumString;
                  GSxmlSettle.Attributes['level']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_level;
                  GSxmlSettle.Attributes['region']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_locationRegion;
                  GSsubL:=length(FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures)-1;
                  GSsubC:=1;
                  while GSsubC<=GSsubL do
                  begin
                     GSxmlColInf:=GSxmlSettle.AddChild('setInfra');
                     GSxmlColInf.Attributes['token']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_token;
                     GSxmlColInf.Attributes['level']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_level;
                     case FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_status of
                        isInKit: GSstringStore:='istInKit';
                        isInConversion: GSstringStore:='istInConversion';
                        isInAssembling: GSstringStore:='istInAssembling';
                        isInBluidingSite: GSstringStore:='istInBldSite';
                        isDisabled: GSstringStore:='istDisabled';
                        isDisabledByEnergyEquilibrium: GSstringStore:='istDisabledByEE';
                        isInTransition: GSstringStore:='istInTransition';
                        isOperational: GSstringStore:='istOperational';
                     end;
                     GSxmlColInf.Attributes['status']:=GSstringStore;
                     GSxmlColInf.Attributes['CABduration']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_cabDuration;
                     GSxmlColInf.Attributes['CABworked']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_cabWorked;
                     GSxmlColInf.Attributes['powerCons']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_powerConsumption;
                     GSxmlColInf.Attributes['powerGencFx']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_powerGeneratedFromCustomEffect;
                     case FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_function of
                        fEnergy:
                        begin
                           GSxmlColInf.Attributes['Func']:='fEnergy';
                           GSxmlColInf.Attributes['energyOut']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fEnOutput;
                        end;

                        fHousing:
                        begin
                           GSxmlColInf.Attributes['Func']:='fHousing';
                           GSxmlColInf.Attributes['PCAP']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fHousPopulationCapacity;
                           GSxmlColInf.Attributes['QOL']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fHousQualityOfLife;
                           GSxmlColInf.Attributes['vol']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fHousCalculatedVolume;
                           GSxmlColInf.Attributes['surf']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fHousCalculatedSurface;
                        end;

                        fIntelligence: GSxmlColInf.Attributes['Func']:='fIntelligence';

                        fMiscellaneous: GSxmlColInf.Attributes['Func']:='fMiscellaneous';

                        fProduction:
                        begin
                           GSxmlColInf.Attributes['Func']:='fProduction';
                           GSxmlColInf.Attributes['surveyedSpot']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fProdSurveyedSpot;
                           GSxmlColInf.Attributes['surveyedRegion']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fProdSurveyedRegion;
                           GSxmlColInf.Attributes['resourceSpot']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fProdResourceSpot;
                           GSsubCount:=1;
                           while GSsubCount<=FCCdipProductionModesMax do
                           begin
                              if FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fProdProductionMode[GSsubCount].PM_type>pmNone then
                              begin
                                 GSxmlProdMode:=GSxmlColInf.AddChild('prodmode');
                                 case FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fProdProductionMode[GSsubCount].PM_type of
                                    pmResourceMining: GSstringStore:='pmResourceMining';
                                 end;
                                 GSxmlProdMode.Attributes['prodModeType']:=GSstringStore;
                                 GSxmlProdMode.Attributes['isDisabled']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fProdProductionMode[GSsubCount].PM_isDisabled;
                                 GSxmlProdMode.Attributes['energyCons']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fProdProductionMode[GSsubCount].PM_energyConsumption;
                                 GSxmlProdMode.Attributes['matrixItemMax']:=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fProdProductionMode[GSsubCount].PM_matrixItemMax;
                                 GSsubCount1:=1;
                                 while GSsubCount1<=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fProdProductionMode[GSsubCount].PM_matrixItemMax do
                                 begin
                                    GSxmlMatrixItem:=GSxmlProdMode.AddChild('linkedMatrixItem');
                                    GSxmlMatrixItem.Attributes['pmitmIndex']
                                       :=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fProdProductionMode[GSsubCount].PM_linkedColonyMatrixItems[GSsubCount1].LMII_matrixItemIndex;
                                    GSxmlMatrixItem.Attributes['pmIndex']
                                       :=FCentities[GScount].E_col[GScolCnt].C_settlements[GSsettleCnt].S_infrastructures[GSsubC].I_fProdProductionMode[GSsubCount].PM_linkedColonyMatrixItems[GSsubCount1].LMII_matrixItem_ProductionModeIndex;
                                    inc(GSsubCount1);
                                 end;
                              end
                              else Break;
                              inc(GSsubCount);
                           end;
                        end;
                     end; //==END== case FCentities[GScount].E_col[GScolCnt].COL_settlements[GSsettleCnt].CS_infra[GSsubC].CI_function of ==//
                     inc(GSsubC);
                  end; //==END== while GSsubC<=GSsubL do ==//
                  inc(GSsettleCnt);
               end; //==END== while GSsettleCnt<=GSsettleMax do ==//
               {.CAB queue}
               GSsettleCnt:=1;
               while GSsettleCnt<=GSsettleMax do
               begin
                  GScabMax:=length(FCentities[GScount].E_col[GScolCnt].C_cabQueue[GSsettleCnt])-1;
                  if GScabMax>0 then
                  begin
                     if GSxmlCABroot=nil
                     then GSxmlCABroot:=GSxmlCol.AddChild('colCAB');
                     GScabCount:=1;
                     while GScabCount<=GScabMax do
                     begin
                        GSxmlCAB:=GSxmlCABroot.AddChild('cabItem');
                        GSxmlCAB.Attributes['settlement']:=GSsettleCnt;
                        GSxmlCAB.Attributes['infraIdx']:=FCentities[GScount].E_col[GScolCnt].C_cabQueue[GSsettleCnt, GScabCount];
                        inc(GScabCount);
                     end;
                  end; //==END== if GScabMax>0 ==//
                  inc(GSsettleCnt);
               end;
               {.production matrix}
               GSprodMatrixMax:=Length(FCentities[GScount].E_col[GScolCnt].C_productionMatrix)-1;
               if GSprodMatrixMax>0 then
               begin
                  GSxmlProdMatrixRoot:=GSxmlCol.AddChild('colProdMatrix');
                  GSprodMatrixCnt:=1;
                  while GSprodMatrixCnt<=GSprodMatrixMax do
                  begin
                     GSxmlProdMatrix:=GSxmlProdMatrixRoot.AddChild('prodItem');
                     GSxmlProdMatrix.Attributes['token']:=FCentities[GScount].E_col[GScolCnt].C_productionMatrix[GSprodMatrixCnt].PM_productToken;
                     GSxmlProdMatrix.Attributes['storIdx']:=FCentities[GScount].E_col[GScolCnt].C_productionMatrix[GSprodMatrixCnt].PM_storageIndex;
                     case FCentities[GScount].E_col[GScolCnt].C_productionMatrix[GSprodMatrixCnt].PM_storage of
                        stSolid: GSstringStore:='stSolid';
                        stLiquid: GSstringStore:='stLiquid';
                        stGas: GSstringStore:='stGas';
                        stBiologic: GSstringStore:='stBiologic';
                     end;
                     GSxmlProdMatrix.Attributes['storageType']:=GSstringStore;
                     GSxmlProdMatrix.Attributes['globalProdFlow']:=FCentities[GScount].E_col[GScolCnt].C_productionMatrix[GSprodMatrixCnt].PM_globalProductionFlow;
                     GSsubMax:=length(FCentities[GScount].E_col[GScolCnt].C_productionMatrix[GSprodMatrixCnt].PM_productionModes)-1;
                     if GSsubMax>0 then
                     begin
                        GSsubCount:=1;
                        while GSsubCount<=GSsubMax do
                        begin
                           GSxmlProdMatrixSource:=GSxmlProdMatrix.AddChild('prodMode');
                           GSxmlProdMatrixSource.Attributes['locSettle']:=FCentities[GScount].E_col[GScolCnt].C_productionMatrix[GSprodMatrixCnt].PM_productionModes[GSsubCount].PM_locationSettlement;
                           GSxmlProdMatrixSource.Attributes['locInfra']:=FCentities[GScount].E_col[GScolCnt].C_productionMatrix[GSprodMatrixCnt].PM_productionModes[GSsubCount].PM_locationInfrastructure;
                           GSxmlProdMatrixSource.Attributes['locPModeIndex']:=FCentities[GScount].E_col[GScolCnt].C_productionMatrix[GSprodMatrixCnt].PM_productionModes[GSsubCount].PM_locationProductionModeIndex;
                           GSxmlProdMatrixSource.Attributes['isDisabledPS']:=FCentities[GScount].E_col[GScolCnt].C_productionMatrix[GSprodMatrixCnt].PM_productionModes[GSsubCount].PM_isDisabledByProductionSegment;
                           GSxmlProdMatrixSource.Attributes['prodFlow']:=FCentities[GScount].E_col[GScolCnt].C_productionMatrix[GSprodMatrixCnt].PM_productionModes[GSsubCount].PM_productionFlow;
                           inc(GSsubCount);
                        end;
                     end;
                     inc(GSprodMatrixCnt);
                  end;
               end;
               {.storage}
               GSxmlstorageRoot:=GSxmlCol.AddChild('colStorage');
               GSxmlstorageRoot.Attributes['capSolidCur']:=FCentities[GScount].E_col[GScolCnt].C_storageCapacitySolidCurrent;
               GSxmlstorageRoot.Attributes['capSolidMax']:=FCentities[GScount].E_col[GScolCnt].C_storageCapacitySolidMax;
               GSxmlstorageRoot.Attributes['capLiquidCur']:=FCentities[GScount].E_col[GScolCnt].C_storageCapacityLiquidCurrent;
               GSxmlstorageRoot.Attributes['capLiquidMax']:=FCentities[GScount].E_col[GScolCnt].C_storageCapacityLiquidMax;
               GSxmlstorageRoot.Attributes['capGasCur']:=FCentities[GScount].E_col[GScolCnt].C_storageCapacityGasCurrent;
               GSxmlstorageRoot.Attributes['capGasMax']:=FCentities[GScount].E_col[GScolCnt].C_storageCapacityGasMax;
               GSxmlstorageRoot.Attributes['capBioCur']:=FCentities[GScount].E_col[GScolCnt].C_storageCapacityBioCurrent;
               GSxmlstorageRoot.Attributes['capBioMax']:=FCentities[GScount].E_col[GScolCnt].C_storageCapacityBioMax;
					GSstorageMax:=length(FCentities[GScount].E_col[GScolCnt].C_storedProducts)-1;
               if GSstorageMax>0 then
               begin
                  GSstorageCnt:=1;
                  while GSstorageCnt<=GSstorageMax do
                  begin
                     GSxmlstorage:=GSxmlstorageRoot.AddChild('storItem'+IntToStr(GSstorageCnt));
                     GSxmlstorage.Attributes['token']:=FCentities[GScount].E_col[GScolCnt].C_storedProducts[GSstorageCnt].SP_token;
                     GSxmlstorage.Attributes['unit']:=FCentities[GScount].E_col[GScolCnt].C_storedProducts[GSstorageCnt].SP_unit;
                     inc(GSstorageCnt);
                  end;
               end;
               {.reserves}
               GSxmlReservesRoot:=GSxmlCol.AddChild('colReserves');
               GSxmlReservesRoot.Attributes['oxygen']:=FCentities[GScount].E_col[GScolCnt].C_reserveOxygen;
               GSxmlReservesRoot.Attributes['food']:=FCentities[GScount].E_col[GScolCnt].C_reserveFood;
               GSstorageMax:=length(FCentities[GScount].E_col[GScolCnt].C_reserveFoodProductsIndex)-1;
               GSstorageCnt:=1;
               while GSstorageCnt<=GSstorageMax do
               begin
                  GSxmlReserves:=GSxmlReservesRoot.AddChild( 'foodRve'+IntToStr( GSstorageCnt ) );
                  GSxmlReserves.Attributes['index']:=FCentities[GScount].E_col[GScolCnt].C_reserveFoodProductsIndex[ GSstorageCnt ];
                  inc(GSstorageCnt);
               end;
               GSxmlReservesRoot.Attributes['water']:=FCentities[GScount].E_col[GScolCnt].C_reserveWater;
            end; //==END== if GSsettleMax>0 ==//
            inc(GScolCnt);
         end; //==END== while GScolCnt<=GScolMax do ==//
      end; //==END== if GScolMax>0 ==//
      GSspmMax:=Length(FCentities[GScount].E_spm)-1;
      if GSspmMax>0
      then
      begin
         GSxmlItm:=GSxmlEnt.AddChild('entSPMset');
         GSxmlItm.Attributes['modCoh']:=FCentities[GScount].E_spmMcohes;
         GSxmlItm.Attributes['modTens']:=FCentities[GScount].E_spmMtens;
         GSxmlItm.Attributes['modSec']:=FCentities[GScount].E_spmMsec;
         GSxmlItm.Attributes['modEdu']:=FCentities[GScount].E_spmMedu;
         GSxmlItm.Attributes['modNat']:=FCentities[GScount].E_spmMnat;
         GSxmlItm.Attributes['modHeal']:=FCentities[GScount].E_spmMhealth;
         GSxmlItm.Attributes['modBur']:=FCentities[GScount].E_spmMBur;
         GSxmlItm.Attributes['modCorr']:=FCentities[GScount].E_spmMCorr;
         GSspmCnt:=1;
         while GSspmCnt<=GSspmMax do
         begin
            GSxmlSPM:=GSxmlItm.AddChild('entSPM');
            GSxmlSPM.Attributes['token']:=FCentities[GScount].E_spm[GSspmCnt].SPMS_token;
            GSxmlSPM.Attributes['duration']:=FCentities[GScount].E_spm[GSspmCnt].SPMS_duration;
            GSxmlSPM.Attributes['ucCost']:=FCentities[GScount].E_spm[GSspmCnt].SPMS_ucCost;
            GSxmlSPM.Attributes['ispolicy']:=FCentities[GScount].E_spm[GSspmCnt].SPMS_isPolicy;
            if FCentities[GScount].E_spm[GSspmCnt].SPMS_isPolicy
            then
            begin
               GSxmlSPM.Attributes['isSet']:=FCentities[GScount].E_spm[GSspmCnt].SPMS_iPtIsSet;
               GSxmlSPM.Attributes['aprob']:=FCentities[GScount].E_spm[GSspmCnt].SPMS_iPtAcceptanceProbability;
            end
            else if not FCentities[GScount].E_spm[GSspmCnt].SPMS_isPolicy
            then
            begin
               GSxmlSPM.Attributes['belieflvl']:=FCentities[GScount].E_spm[GSspmCnt].SPMS_iPtBeliefLevel;
               GSxmlSPM.Attributes['spreadval']:=FCentities[GScount].E_spm[GSspmCnt].SPMS_iPtAcceptanceProbability;
            end;
            inc(GSspmCnt);
         end;
      end;
      inc(GScount);
   end; //==END== while GScount<=FCCfacMax do ==//
   {.create "msgqueue" saved game item}
   GSlength:=length(FCVmsgStoMsg);
   if GSlength>1
   then
   begin
      GSxmlItm:=GSxmlRoot.AddChild('gfMsgQueue');
      GScount:=1;
      while GScount<=GSlength-1 do
      begin
         GSxmlMsg:=GSxmlItm.AddChild('gfMsg');
         GSxmlMsg.Attributes['msgTitle']:=FCVmsgStoTtl[GScount];
         GSxmlMsg.Attributes['msgMain']:=FCVmsgStoMsg[GScount];
         inc(GScount);
      end; {.while GScount<=GSlength-1}
   end; {.if GSlength>1 then}
   FCWinMain.FCGLSHUDgameTime.Text:='Game Saved';
   {.write the file and free the memory}
   FCWinMain.FCXMLsave.SaveToFile(GScurrDir+'\'+GScurrG);
   FCWinMain.FCXMLsave.Active:=false;
   if not FCWinMain.CloseQuery
   then FCMgTFlow_FlowState_Set(tphTac);
end;

procedure FCMdFSG_Game_SaveAndFlushOther;
{:Purpose: save the current game and flush all other save game files than the current one.
    Additions:
}
var
   SFOtimeDay
   ,SFOtimeHr
   ,SFOtimeMin
   ,SFOtimeMth
   ,SFOtimeTick
   ,SFOtimeYr: integer;

   SFOcurrDir
   ,SFOcurrG: string;

   SFOxmlCurrGame: IXMLNode;
begin
   try
      FCMdFSG_Game_Save;
   finally
      {.read the document}
      FCWinMain.FCXMLcfg.FileName:=FCVdiPathConfigFile;
      FCWinMain.FCXMLcfg.Active:=true;
      SFOxmlCurrGame:=FCWinMain.FCXMLcfg.DocumentElement.ChildNodes.FindNode('currGame');
      if SFOxmlCurrGame<>nil
      then
      begin
         SFOtimeTick:=SFOxmlCurrGame.Attributes['tfTick'];
         SFOtimeMin:=SFOxmlCurrGame.Attributes['tfMin'];
         SFOtimeHr:=SFOxmlCurrGame.Attributes['tfHr'];
         SFOtimeDay:=SFOxmlCurrGame.Attributes['tfDay'];
         SFOtimeMth:=SFOxmlCurrGame.Attributes['tfMth'];
         SFOtimeYr:=SFOxmlCurrGame.Attributes['tfYr'];
      end;
      {.free the memory}
      FCWinMain.FCXMLcfg.Active:=false;
      FCWinMain.FCXMLcfg.FileName:='';
      SFOcurrDir:=FCVdiPathConfigDir+'SavedGames\'+FCRplayer.P_gameName;
      SFOcurrG:=IntToStr(SFOtimeYr)
         +'-'+IntToStr(SFOtimeMth)
         +'-'+IntToStr(SFOtimeDay)
         +'-'+IntToStr(SFOtimeHr)
         +'-'+IntToStr(SFOtimeMin)
         +'.xml';
      if FileExists(SFOcurrDir+'\'+SFOcurrG)
      then
      begin
         CopyFile(pchar(SFOcurrDir+'\'+SFOcurrG),pchar(FCVdiPathConfigDir+SFOcurrG),false);
         FCMcF_Files_Del(SFOcurrDir+'\','*.*');
         CopyFile(pchar(FCVdiPathConfigDir+SFOcurrG),pchar(SFOcurrDir+'\'+SFOcurrG),false);
         DeleteFile(pchar(FCVdiPathConfigDir+SFOcurrG));
      end;
   end;
end;

end.
